# emu_data_loader/loader.py

class EMUDataLoader:
    def __init__(self, filename=None,
               start=None,
               patient_ID="PY23N000",
               date="1/01/2023 00:00:00 - 1/01/2023 00:00:00",
               preload_annot=True,
               preload_A=False,
               preload_SI=False,
               preload_eeg=False,
               center="CC_Python"):
        """ A class to help import Johns Hopkins' EMU data into Python.

        Args:
            filename: File name used in the database, for example "FA_1"
            start: Start time of recording in 24 hrs format, for example "12:00:00"
            SZ_onset_iW: Start A index of seizure event. Optional.
            SZ_offset_iW: End A index of seizure event. Optional.
            load_annot: Loads the annotations from X_i_annot.csv CSV files generated by MATLAB from EMU annotations.
            patient_ID: The study ID of the patient, for example "PY23N000"
            center: Center that the data was collected in. MC=Multi-Center, JH=JohnsHopkins, ETH=ETH
        """

        self.filename = filename
        self.start_time = start

        if filename is None:
            raise Exception("No filename to load")

        if center == "JH":
            self.data_dir = f'D:\\{patient_ID}'
        elif center in ["MC", "ETH", "CC"]:
            self.data_dir = f'E:\\{patient_ID}'
        elif center == 'CC_Python':
            self.data_dir = f'E:\\{patient_ID}'

        output_dir = 'C:\\Users\\adaraie\\Desktop\\NCSL_Desk\\Prediction\\Codes\\Python'

        self.pID = patient_ID
        self.date = date

        self.center = center

        self.load_A(preload_A)
        self.load_SI(preload_SI)
        self.load_annot(preload_annot)
        self.load_eeg(preload_eeg)

    def load_annot(self, preload_annot):
        # Now import the annotations for the file
        if preload_annot:
            fpath_annot = pjoin(self.data_dir, '7_annot_indices', f'{self.filename}_annot.csv')

            try:
                annot_df = pd.read_csv(fpath_annot)
                print(annot_df)
                self.SZ_onset_iW = list(annot_df["Aidx_iW"])
                self.SZ_onset_annot = list(annot_df["Annot"])
                self.SZ_onset_time = list(annot_df["Time"])
                self.SegNumber = list(annot_df["SegNumber"])
            except:
                print(f"The annotation file {self.filename}_annot.csv is empty")
                self.SZ_onset_iW = None
                self.SZ_onset_annot = None
                self.SZ_onset_time = None
                self.SegNumber = None

            print(f"DONE: Importing annotations for {self.filename}...\n")

        else:
            self.SZ_onset_iW = None
            self.SZ_onset_annot = None
            self.SZ_onset_time = None
            self.SegNumber = None
            print(f":WARNING: NO annotations to load for {self.filename}...\n")

    def load_A(self, preload_A):
        if preload_A:
            if self.center in ["CC_Python"]:
                fpath_SI = pjoin(self.data_dir, '4_a_matrices', f'{self.filename}_A.mat')
                A_file = sio.loadmat(fpath_SI)
                self.A = A_file['A_hat']
                self.win_size = A_file["win_size"]
                self.nWin = A_file['A_hat'].shape[2]
                self.labels = A_file['labels']
                self.factor = A_file['factor'] # downsampling downsampling
                self.fs = A_file['fs'] # sampling frequency after downsampling
                self.fs0 = A_file['fs0'] # sampling frequency before downsampling
                self.labels = A_file['labels']
                print(f"DONE: Importing sink indices for {self.filename}...\n")
            else:
                print(f"WARNING: The center `{self.center}` is not defined for loading A matrices...\n")
        else:
            print(f"WARNING: NO sink indices to load for {self.filename}...\n")


    def load_SI(self, preload_SI=True):
        # allocate a memory for these variables
        self.SI1 = []
        self.SI2 = []
        self.SI3 = []
        self.SI = []
        self.rr = [] # Row ranks
        self.cr = [] # Column ranks
        self.t_sec = []
        self.nWin = []
        self.labels = []

        if preload_SI:
            if self.center in ["MC", "ETH", "CC", "JH"]:
                # Now import the data for the file
                fpath_SI = pjoin(self.data_dir, '5_sink_indices', f'{self.filename}_SI.mat')

                SI_file = sio.loadmat(fpath_SI)

                self.SI1 = SI_file['SI1_wins']
                self.SI1 = np.log10(self.SI1)
                self.SI1 = (self.SI1).T  # dim example: (28800, 34)

                self.SI2 = SI_file['SI2_wins']
                self.SI2 = self.SI2.T # dim example: (28800, 34)

                try: # wrote this because some sink index files may not yet have SI3
                    self.SI3 = SI_file['SI3_wins']
                    self.SI3 = self.SI3.T # dim example: (28800, 34)
                except:
                    self.SI3 = []

                self.rr = SI_file['row_ranks_wins'].T
                self.cr = SI_file['col_ranks_wins'].T

                self.t_sec = SI_file['t_sec'].squeeze()
                self.nWin = SI_file['SI1_wins'].shape[1]

                self.labels = SI_file['labels_sort']

                # Sort labels in alphabetical order
                labels_tmp = np.copy(np.squeeze(self.labels))
                for k, lab in enumerate(labels_tmp): labels_tmp[k] = lab[0]
                labels_tmp = labels_tmp.tolist()
                from operator import itemgetter
                indices, labels_tmp = zip(*sorted(enumerate(labels_tmp), key=itemgetter(1)))
                self.labels = np.copy(labels_tmp)

                # Rearrange sink indices with the new sorting of the channel labels
                self.SI1 = self.SI1[:, indices]
                self.SI2 = self.SI2[:, indices]

                if not len(self.SI3) == 0: # wrote this because some sink index files may not yet have SI3
                    self.SI3 = self.SI3[:, indices]

                print(f"DONE: Importing sink indices for {self.filename}...\n")

            elif self.center in ["CC_Python"]:
                fpath_SI = pjoin(self.data_dir, '5_sink_indices', f'{self.filename}_SI.mat')
                SI_file = sio.loadmat(fpath_SI)
                self.SI = SI_file['SI_wins'].T
                self.rr = SI_file['row_ranks'].T
                self.cr = SI_file['col_ranks'].T
                self.nWin = self.SI.shape[0]
                self.labels = SI_file['labels']
                print(f"DONE: Importing sink indices for {self.filename}...\n")
        else:
            print(f"WARNING: NO sink indices to load for {self.filename}...\n")

    def load_eeg(self, preload_eeg=False, load_filterd=False, filter=True):
        # allocate a memory for these variables
        self.data_eeg = []
        self.channels_eeg = []
        self.eeg = []

        if preload_eeg:
            if self.center == "JH":
                # Now import EEGs for the file
                if load_filterd:
                    fpath_eeg = pjoin(self.data_dir, '3_segmented', 'filtered', f'{self.filename}_filtered.edf')
                else:
                    fpath_eeg = pjoin(self.data_dir, '3_segmented', f'{self.filename}.edf')

                self.eeg = mne.io.read_raw_edf(fpath_eeg)

                if load_filterd == False and filter == True:
                    self.eeg.load_data()
                    print(self.eeg.info["sfreq"])
                    self.eeg = self.eeg.filter(l_freq=0.5, h_freq=120)
                    freqs = (60, 120)
                    self.eeg = self.eeg.notch_filter(freqs=freqs)

                raw_data = self.eeg.get_data()
                info = self.eeg.info
                channels = self.eeg.ch_names
                channs = []
                if load_filterd == False:
                    # Remove POL from channels
                    for chi in channels:
                        channs.append(chi[4:])
                    channels = channs

                # Sort channels by channel name
                indices = sorted(
                    range(len(channels)),
                    key=lambda index: channels[index],
                    reverse = False
                )
                sorted_channels = [channels[index] for index in indices]
                # Sort the data based on sorted channels
                self.data_eeg = raw_data[indices, :]
                self.channels_eeg = sorted_channels
                print(f"DONE: Importing EEGs for {self.filename}...\n")

            elif self.center in ["CC", "CC_Python"]: # Hard drive of Kristin and Adam
                fpath_eeg = pjoin(self.data_dir, '3_segmented', f'{self.filename}.mat')
                self.eeg = sio.loadmat(fpath_eeg)['pt_data'][0]
                self.data_eeg = self.eeg['data_filt'][0]
                eeg_labels = self.eeg['labels'][0]
                self.channels_eeg = []
                for i in range(len(eeg_labels)):
                    self.channels_eeg.append(eeg_labels[i][0][0])
                print(f"DONE: Importing EEGs for {self.filename}...\n")

            elif self.center == "OpenNeuro": # webstie
                fpath_eeg = pjoin(self.data_dir, '3_segmented', f'{self.filename}.mat')
                self.eeg = sio.loadmat(fpath_eeg)
                self.data_eeg = self.eeg['data_filt'][0][0]
                eeg_labels = self.eeg['labels'][0][0].tolist()
                self.channels_eeg = [labi.strip() for labi in eeg_labels]
                print(f"DONE: Importing EEGs for {self.filename}...\n")

    def delete_eeg(self):
        del self.data_eeg
        del self.channels_eeg
        del self.eeg
        self.eeg = []
        self.data_eeg = []
        self.channels_eeg = []
        print(f"DONE: Deleting EEGs for {self.filename}...\n")

    def delete_SI(self):
        del self.SI1
        del self.SI2
        del self.SI3
        del self.t_sec
        del self.nWin
        del self.labels
        print(f"DONE: Deleting sink indices for {self.filename}...\n")

    def __del__(self):
        self.delete_SI()
        self.delete_eeg()