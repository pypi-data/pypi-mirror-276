import difflib
import unicodedata

from fugashi import Tagger
from jaconv import jaconv


def _is_kanji(ch):
    return 'CJK UNIFIED IDEOGRAPH' in unicodedata.name(ch)


def _get_pairs(origin: str, kana: str) -> list[tuple]:
    ret = list()
    if any(_is_kanji(_) for _ in origin):
        hiragana = jaconv.kata2hira(kana)
        for p in _generate_furigana_pairs(origin, hiragana):
            ret.append(p)
    else:
        ret.append((origin,))
    return ret


def _get_pair_list(text: str) -> list[tuple]:
    tagger = Tagger()
    ret = list()
    for word in tagger(text):
        origin = word.feature.orth
        kana = word.feature.kana
        if origin is None and kana is None:
            ret.append((word.surface,))
            continue
        pairs = _get_pairs(origin, kana)
        ret.extend(pairs)
    return ret


def _get_furigana_html(tuple_list: list[tuple]) -> str:
    str_list = list()
    for pair in tuple_list:
        if len(pair) == 2:
            kanji, hira = pair
            str_list.append("<ruby>{0}<rt>{1}</rt></ruby>".format(kanji, hira))
        else:
            str_list.append(pair[0])
    return ''.join(str_list)


k_special_replacing_char = '#'


def _replace_last_char_with(text, replacing_text):
    string_list = list(text)

    # Replace last character with special char
    string_list[-1] = replacing_text

    # Convert list back to string
    modified_string = ''.join(string_list)

    return modified_string


def _generate_furigana_pairs(str1, str2):
    # Ref: this code is mostly generated by chatGPT
    # for special case 忙しい[いそがい]
    is_first_and_last_are_same = str2[0] == str2[-1] and str1[-1] == str2[-1]
    replaced_char = None
    if is_first_and_last_are_same:
        replaced_char = str2[-1]
        str2 = _replace_last_char_with(str2, k_special_replacing_char)
        str1 = _replace_last_char_with(str1, k_special_replacing_char)

    matcher = difflib.SequenceMatcher(None, str1, str2)

    blocks = matcher.get_matching_blocks()
    result = []
    prev_end_a = prev_end_b = 0

    for block in blocks:
        if block.size == 0:
            continue

        # Non-matching part before this matching block
        non_match_a = str1[prev_end_a:block.a]
        non_match_b = str2[prev_end_b:block.b]

        if non_match_a or non_match_b:
            result.append((non_match_a, non_match_b))

        # Matching part
        matching_segment = str1[block.a:block.a + block.size]
        if matching_segment:
            result.append((matching_segment,))

        prev_end_a = block.a + block.size
        prev_end_b = block.b + block.size

    # Handle any remaining non-matching parts after the last matching block
    non_match_a = str1[prev_end_a:]
    non_match_b = str2[prev_end_b:]
    if non_match_a or non_match_b:
        result.append((non_match_a, non_match_b))

    # for special case
    if is_first_and_last_are_same:
        another_result = list()
        for r in result:
            if k_special_replacing_char in r[0]:
                another_result.append((_replace_last_char_with(r[0], replaced_char),))
            else:
                another_result.append(r)

        return another_result

    return result
