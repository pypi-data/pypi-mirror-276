# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
import urllib.parse
from json.decoder import JSONDecodeError

from .....core.api_error import ApiError
from .....core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .....core.jsonable_encoder import jsonable_encoder
from .....core.remove_none_from_dict import remove_none_from_dict
from ....commons.errors.entity_conflict_error import EntityConflictError
from ....commons.errors.entity_not_found_error import EntityNotFoundError
from ....commons.types.entity_conflict_error_message import EntityConflictErrorMessage
from ....commons.types.entity_not_found_error_message import EntityNotFoundErrorMessage
from ....commons.types.error_message import ErrorMessage
from ....commons.types.facility_type_code import FacilityTypeCode
from ....commons.types.network_type import NetworkType
from ....commons.types.page_token import PageToken
from ....commons.types.procedure_modifier import ProcedureModifier
from ....commons.types.rate_id import RateId
from ....commons.types.service_line_id import ServiceLineId
from ....commons.types.state import State
from ....organization_providers.resources.v_2.types.license_type import LicenseType
from ....organization_providers.resources.v_2.types.organization_provider_id import OrganizationProviderId
from ....payers.resources.v_3.types.payer_uuid import PayerUuid
from .errors.failed_to_build_service_line_dimensions import FailedToBuildServiceLineDimensions
from .errors.fee_schedule_validation_http_error import FeeScheduleValidationHttpError
from .types.dimension_name import DimensionName
from .types.dimensions_page import DimensionsPage
from .types.match_result import MatchResult
from .types.match_test_result import MatchTestResult
from .types.payer_threshold import PayerThreshold
from .types.payer_thresholds_page import PayerThresholdsPage
from .types.rate import Rate
from .types.rate_upload import RateUpload
from .types.rate_upload_with_possible_errors import RateUploadWithPossibleErrors
from .types.rates_page import RatesPage

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class V3Client:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_match(self, service_line_id: ServiceLineId) -> typing.Optional[MatchResult]:
        """
        Gets the rate that matches a service line. No result means no rate exists matching the service line's dimensions.

        Parameters:
            - service_line_id: ServiceLineId.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/fee-schedules/v3/service-line/{service_line_id}/match"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Optional[MatchResult], _response_json)  # type: ignore
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    pydantic.parse_obj_as(EntityNotFoundErrorMessage, _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "FailedToBuildServiceLineDimensions":
                raise FailedToBuildServiceLineDimensions(
                    pydantic.parse_obj_as(ErrorMessage, _response_json["content"])  # type: ignore
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def test_match(self, service_line_id: ServiceLineId, rate_id: RateId) -> MatchTestResult:
        """
        Tests a service line against a rate to see if it matches.

        Parameters:
            - service_line_id: ServiceLineId.

            - rate_id: RateId.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/fee-schedules/v3/service-line/{service_line_id}/match/{rate_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(MatchTestResult, _response_json)  # type: ignore
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    pydantic.parse_obj_as(EntityNotFoundErrorMessage, _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "FailedToBuildServiceLineDimensions":
                raise FailedToBuildServiceLineDimensions(
                    pydantic.parse_obj_as(ErrorMessage, _response_json["content"])  # type: ignore
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_multi(
        self,
        *,
        page_token: typing.Optional[PageToken] = None,
        limit: typing.Optional[int] = None,
        active_date: typing.Optional[dt.date] = None,
        payer_uuid: typing.Optional[PayerUuid] = None,
        organization_billing_provider_id: typing.Optional[OrganizationProviderId] = None,
        states: typing.Optional[typing.Union[State, typing.List[State]]] = None,
        zip_codes: typing.Optional[typing.Union[str, typing.List[str]]] = None,
        license_types: typing.Optional[typing.Union[LicenseType, typing.List[LicenseType]]] = None,
        facility_type_codes: typing.Optional[typing.Union[FacilityTypeCode, typing.List[FacilityTypeCode]]] = None,
        network_types: typing.Optional[typing.Union[NetworkType, typing.List[NetworkType]]] = None,
        cpt_code: typing.Optional[str] = None,
        modifiers: typing.Optional[typing.Union[ProcedureModifier, typing.List[ProcedureModifier]]] = None,
    ) -> RatesPage:
        """
        Gets a list of dimensions with their rates. The rates returned will always be the most recent versions of those rates.

        Parameters:
            - page_token: typing.Optional[PageToken].

            - limit: typing.Optional[int]. Max number of dimensions returned. Defaults to 100. Max is 100.

            - active_date: typing.Optional[dt.date].

            - payer_uuid: typing.Optional[PayerUuid].

            - organization_billing_provider_id: typing.Optional[OrganizationProviderId].

            - states: typing.Optional[typing.Union[State, typing.List[State]]].

            - zip_codes: typing.Optional[typing.Union[str, typing.List[str]]].

            - license_types: typing.Optional[typing.Union[LicenseType, typing.List[LicenseType]]].

            - facility_type_codes: typing.Optional[typing.Union[FacilityTypeCode, typing.List[FacilityTypeCode]]].

            - network_types: typing.Optional[typing.Union[NetworkType, typing.List[NetworkType]]].

            - cpt_code: typing.Optional[str].

            - modifiers: typing.Optional[typing.Union[ProcedureModifier, typing.List[ProcedureModifier]]].
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/fee-schedules/v3"),
            params=remove_none_from_dict(
                {
                    "page_token": page_token,
                    "limit": limit,
                    "active_date": str(active_date) if active_date is not None else None,
                    "payer_uuid": jsonable_encoder(payer_uuid),
                    "organization_billing_provider_id": jsonable_encoder(organization_billing_provider_id),
                    "states": states,
                    "zip_codes": zip_codes,
                    "license_types": license_types,
                    "facility_type_codes": facility_type_codes,
                    "network_types": network_types,
                    "cpt_code": cpt_code,
                    "modifiers": modifiers,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RatesPage, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_unique_values_for_dimension(
        self,
        *,
        page_token: typing.Optional[PageToken] = None,
        limit: typing.Optional[int] = None,
        pivot_dimension: DimensionName,
        payer_uuid: typing.Optional[PayerUuid] = None,
        organization_billing_provider_id: typing.Optional[OrganizationProviderId] = None,
        states: typing.Optional[typing.Union[State, typing.List[State]]] = None,
        zip_codes: typing.Optional[typing.Union[str, typing.List[str]]] = None,
        license_types: typing.Optional[typing.Union[LicenseType, typing.List[LicenseType]]] = None,
        facility_type_codes: typing.Optional[typing.Union[FacilityTypeCode, typing.List[FacilityTypeCode]]] = None,
        network_types: typing.Optional[typing.Union[NetworkType, typing.List[NetworkType]]] = None,
        cpt_code: typing.Optional[str] = None,
        modifiers: typing.Optional[typing.Union[ProcedureModifier, typing.List[ProcedureModifier]]] = None,
    ) -> DimensionsPage:
        """
        Gets unique values for a dimension based on other selection criteria. The response is a list of dimensions with your criteria and the unique values populated. This API is useful for driving pivots on dimension values.

        Parameters:
            - page_token: typing.Optional[PageToken].

            - limit: typing.Optional[int]. Max number of values returned. Defaults to 1000. Max is 1000.

            - pivot_dimension: DimensionName. The name of the dimension to fetch unique values for.

            - payer_uuid: typing.Optional[PayerUuid].

            - organization_billing_provider_id: typing.Optional[OrganizationProviderId].

            - states: typing.Optional[typing.Union[State, typing.List[State]]].

            - zip_codes: typing.Optional[typing.Union[str, typing.List[str]]].

            - license_types: typing.Optional[typing.Union[LicenseType, typing.List[LicenseType]]].

            - facility_type_codes: typing.Optional[typing.Union[FacilityTypeCode, typing.List[FacilityTypeCode]]].

            - network_types: typing.Optional[typing.Union[NetworkType, typing.List[NetworkType]]].

            - cpt_code: typing.Optional[str].

            - modifiers: typing.Optional[typing.Union[ProcedureModifier, typing.List[ProcedureModifier]]].
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "api/fee-schedules/v3/unique-dimension-values"
            ),
            params=remove_none_from_dict(
                {
                    "page_token": page_token,
                    "limit": limit,
                    "pivot_dimension": pivot_dimension,
                    "payer_uuid": jsonable_encoder(payer_uuid),
                    "organization_billing_provider_id": jsonable_encoder(organization_billing_provider_id),
                    "states": states,
                    "zip_codes": zip_codes,
                    "license_types": license_types,
                    "facility_type_codes": facility_type_codes,
                    "network_types": network_types,
                    "cpt_code": cpt_code,
                    "modifiers": modifiers,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DimensionsPage, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_rate_history(self, rate_id: RateId) -> typing.List[Rate]:
        """
        Gets every version of a rate.

        Parameters:
            - rate_id: RateId.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/fee-schedules/v3/{rate_id}/history"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Rate], _response_json)  # type: ignore
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    pydantic.parse_obj_as(EntityNotFoundErrorMessage, _response_json["content"])  # type: ignore
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def upload_fee_schedule(self, *, dry_run: bool, rates: typing.List[RateUpload]) -> typing.List[Rate]:
        """
        Uploads a new fee schedule.\n Each rate may either be totally new as qualified by it's dimensions or a new version for an existing rate.\n If adding a new version to an existing rate, the rate must be posted with the next version number (previous version + 1) or a EntityConflictError will be returned.\n Use the dry run flag to discover already existing rates and to run validations. If validations for any rate fail, no rates will be saved to the system.

        Parameters:
            - dry_run: bool.

            - rates: typing.List[RateUpload].
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/fee-schedules/v3"),
            json=jsonable_encoder({"dry_run": dry_run, "rates": rates}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Rate], _response_json)  # type: ignore
        if "errorName" in _response_json:
            if _response_json["errorName"] == "FeeScheduleValidationHttpError":
                raise FeeScheduleValidationHttpError(
                    pydantic.parse_obj_as(typing.List[RateUploadWithPossibleErrors], _response_json["content"])  # type: ignore
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_rate(self, rate_id: RateId, version: int) -> None:
        """
        Soft deletes a rate from the system. Only the most recent version of a rate can be deleted.

        Parameters:
            - rate_id: RateId.

            - version: int.
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/fee-schedules/v3/{rate_id}/{version}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    pydantic.parse_obj_as(EntityNotFoundErrorMessage, _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "EntityConflictError":
                raise EntityConflictError(
                    pydantic.parse_obj_as(EntityConflictErrorMessage, _response_json["content"])  # type: ignore
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_payer_thresholds_default(self) -> PayerThreshold:
        """
        Gets the default payer threshold
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "api/fee-schedules/v3/payer-threshold/default"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PayerThreshold, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_payer_thresholds(
        self, *, payer_uuids: typing.Union[PayerUuid, typing.List[PayerUuid]]
    ) -> PayerThresholdsPage:
        """
        Gets a list of payers and thresholds by their uuids

        Parameters:
            - payer_uuids: typing.Union[PayerUuid, typing.List[PayerUuid]].
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/fee-schedules/v3/payer-threshold"),
            params=remove_none_from_dict({"payer_uuids": jsonable_encoder(payer_uuids)}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PayerThresholdsPage, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def set_payer_threshold(self, payer_uuid: PayerUuid, *, request: PayerThreshold) -> PayerThreshold:
        """
        Sets the threshold information for a payer

        Parameters:
            - payer_uuid: PayerUuid.

            - request: PayerThreshold.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/fee-schedules/v3/payer-threshold/{payer_uuid}"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PayerThreshold, _response_json)  # type: ignore
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    pydantic.parse_obj_as(EntityNotFoundErrorMessage, _response_json["content"])  # type: ignore
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncV3Client:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_match(self, service_line_id: ServiceLineId) -> typing.Optional[MatchResult]:
        """
        Gets the rate that matches a service line. No result means no rate exists matching the service line's dimensions.

        Parameters:
            - service_line_id: ServiceLineId.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/fee-schedules/v3/service-line/{service_line_id}/match"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Optional[MatchResult], _response_json)  # type: ignore
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    pydantic.parse_obj_as(EntityNotFoundErrorMessage, _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "FailedToBuildServiceLineDimensions":
                raise FailedToBuildServiceLineDimensions(
                    pydantic.parse_obj_as(ErrorMessage, _response_json["content"])  # type: ignore
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def test_match(self, service_line_id: ServiceLineId, rate_id: RateId) -> MatchTestResult:
        """
        Tests a service line against a rate to see if it matches.

        Parameters:
            - service_line_id: ServiceLineId.

            - rate_id: RateId.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/fee-schedules/v3/service-line/{service_line_id}/match/{rate_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(MatchTestResult, _response_json)  # type: ignore
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    pydantic.parse_obj_as(EntityNotFoundErrorMessage, _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "FailedToBuildServiceLineDimensions":
                raise FailedToBuildServiceLineDimensions(
                    pydantic.parse_obj_as(ErrorMessage, _response_json["content"])  # type: ignore
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_multi(
        self,
        *,
        page_token: typing.Optional[PageToken] = None,
        limit: typing.Optional[int] = None,
        active_date: typing.Optional[dt.date] = None,
        payer_uuid: typing.Optional[PayerUuid] = None,
        organization_billing_provider_id: typing.Optional[OrganizationProviderId] = None,
        states: typing.Optional[typing.Union[State, typing.List[State]]] = None,
        zip_codes: typing.Optional[typing.Union[str, typing.List[str]]] = None,
        license_types: typing.Optional[typing.Union[LicenseType, typing.List[LicenseType]]] = None,
        facility_type_codes: typing.Optional[typing.Union[FacilityTypeCode, typing.List[FacilityTypeCode]]] = None,
        network_types: typing.Optional[typing.Union[NetworkType, typing.List[NetworkType]]] = None,
        cpt_code: typing.Optional[str] = None,
        modifiers: typing.Optional[typing.Union[ProcedureModifier, typing.List[ProcedureModifier]]] = None,
    ) -> RatesPage:
        """
        Gets a list of dimensions with their rates. The rates returned will always be the most recent versions of those rates.

        Parameters:
            - page_token: typing.Optional[PageToken].

            - limit: typing.Optional[int]. Max number of dimensions returned. Defaults to 100. Max is 100.

            - active_date: typing.Optional[dt.date].

            - payer_uuid: typing.Optional[PayerUuid].

            - organization_billing_provider_id: typing.Optional[OrganizationProviderId].

            - states: typing.Optional[typing.Union[State, typing.List[State]]].

            - zip_codes: typing.Optional[typing.Union[str, typing.List[str]]].

            - license_types: typing.Optional[typing.Union[LicenseType, typing.List[LicenseType]]].

            - facility_type_codes: typing.Optional[typing.Union[FacilityTypeCode, typing.List[FacilityTypeCode]]].

            - network_types: typing.Optional[typing.Union[NetworkType, typing.List[NetworkType]]].

            - cpt_code: typing.Optional[str].

            - modifiers: typing.Optional[typing.Union[ProcedureModifier, typing.List[ProcedureModifier]]].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/fee-schedules/v3"),
            params=remove_none_from_dict(
                {
                    "page_token": page_token,
                    "limit": limit,
                    "active_date": str(active_date) if active_date is not None else None,
                    "payer_uuid": jsonable_encoder(payer_uuid),
                    "organization_billing_provider_id": jsonable_encoder(organization_billing_provider_id),
                    "states": states,
                    "zip_codes": zip_codes,
                    "license_types": license_types,
                    "facility_type_codes": facility_type_codes,
                    "network_types": network_types,
                    "cpt_code": cpt_code,
                    "modifiers": modifiers,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RatesPage, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_unique_values_for_dimension(
        self,
        *,
        page_token: typing.Optional[PageToken] = None,
        limit: typing.Optional[int] = None,
        pivot_dimension: DimensionName,
        payer_uuid: typing.Optional[PayerUuid] = None,
        organization_billing_provider_id: typing.Optional[OrganizationProviderId] = None,
        states: typing.Optional[typing.Union[State, typing.List[State]]] = None,
        zip_codes: typing.Optional[typing.Union[str, typing.List[str]]] = None,
        license_types: typing.Optional[typing.Union[LicenseType, typing.List[LicenseType]]] = None,
        facility_type_codes: typing.Optional[typing.Union[FacilityTypeCode, typing.List[FacilityTypeCode]]] = None,
        network_types: typing.Optional[typing.Union[NetworkType, typing.List[NetworkType]]] = None,
        cpt_code: typing.Optional[str] = None,
        modifiers: typing.Optional[typing.Union[ProcedureModifier, typing.List[ProcedureModifier]]] = None,
    ) -> DimensionsPage:
        """
        Gets unique values for a dimension based on other selection criteria. The response is a list of dimensions with your criteria and the unique values populated. This API is useful for driving pivots on dimension values.

        Parameters:
            - page_token: typing.Optional[PageToken].

            - limit: typing.Optional[int]. Max number of values returned. Defaults to 1000. Max is 1000.

            - pivot_dimension: DimensionName. The name of the dimension to fetch unique values for.

            - payer_uuid: typing.Optional[PayerUuid].

            - organization_billing_provider_id: typing.Optional[OrganizationProviderId].

            - states: typing.Optional[typing.Union[State, typing.List[State]]].

            - zip_codes: typing.Optional[typing.Union[str, typing.List[str]]].

            - license_types: typing.Optional[typing.Union[LicenseType, typing.List[LicenseType]]].

            - facility_type_codes: typing.Optional[typing.Union[FacilityTypeCode, typing.List[FacilityTypeCode]]].

            - network_types: typing.Optional[typing.Union[NetworkType, typing.List[NetworkType]]].

            - cpt_code: typing.Optional[str].

            - modifiers: typing.Optional[typing.Union[ProcedureModifier, typing.List[ProcedureModifier]]].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "api/fee-schedules/v3/unique-dimension-values"
            ),
            params=remove_none_from_dict(
                {
                    "page_token": page_token,
                    "limit": limit,
                    "pivot_dimension": pivot_dimension,
                    "payer_uuid": jsonable_encoder(payer_uuid),
                    "organization_billing_provider_id": jsonable_encoder(organization_billing_provider_id),
                    "states": states,
                    "zip_codes": zip_codes,
                    "license_types": license_types,
                    "facility_type_codes": facility_type_codes,
                    "network_types": network_types,
                    "cpt_code": cpt_code,
                    "modifiers": modifiers,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DimensionsPage, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_rate_history(self, rate_id: RateId) -> typing.List[Rate]:
        """
        Gets every version of a rate.

        Parameters:
            - rate_id: RateId.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/fee-schedules/v3/{rate_id}/history"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Rate], _response_json)  # type: ignore
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    pydantic.parse_obj_as(EntityNotFoundErrorMessage, _response_json["content"])  # type: ignore
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def upload_fee_schedule(self, *, dry_run: bool, rates: typing.List[RateUpload]) -> typing.List[Rate]:
        """
        Uploads a new fee schedule.\n Each rate may either be totally new as qualified by it's dimensions or a new version for an existing rate.\n If adding a new version to an existing rate, the rate must be posted with the next version number (previous version + 1) or a EntityConflictError will be returned.\n Use the dry run flag to discover already existing rates and to run validations. If validations for any rate fail, no rates will be saved to the system.

        Parameters:
            - dry_run: bool.

            - rates: typing.List[RateUpload].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/fee-schedules/v3"),
            json=jsonable_encoder({"dry_run": dry_run, "rates": rates}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Rate], _response_json)  # type: ignore
        if "errorName" in _response_json:
            if _response_json["errorName"] == "FeeScheduleValidationHttpError":
                raise FeeScheduleValidationHttpError(
                    pydantic.parse_obj_as(typing.List[RateUploadWithPossibleErrors], _response_json["content"])  # type: ignore
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_rate(self, rate_id: RateId, version: int) -> None:
        """
        Soft deletes a rate from the system. Only the most recent version of a rate can be deleted.

        Parameters:
            - rate_id: RateId.

            - version: int.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/fee-schedules/v3/{rate_id}/{version}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    pydantic.parse_obj_as(EntityNotFoundErrorMessage, _response_json["content"])  # type: ignore
                )
            if _response_json["errorName"] == "EntityConflictError":
                raise EntityConflictError(
                    pydantic.parse_obj_as(EntityConflictErrorMessage, _response_json["content"])  # type: ignore
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_payer_thresholds_default(self) -> PayerThreshold:
        """
        Gets the default payer threshold
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "api/fee-schedules/v3/payer-threshold/default"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PayerThreshold, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_payer_thresholds(
        self, *, payer_uuids: typing.Union[PayerUuid, typing.List[PayerUuid]]
    ) -> PayerThresholdsPage:
        """
        Gets a list of payers and thresholds by their uuids

        Parameters:
            - payer_uuids: typing.Union[PayerUuid, typing.List[PayerUuid]].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/fee-schedules/v3/payer-threshold"),
            params=remove_none_from_dict({"payer_uuids": jsonable_encoder(payer_uuids)}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PayerThresholdsPage, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def set_payer_threshold(self, payer_uuid: PayerUuid, *, request: PayerThreshold) -> PayerThreshold:
        """
        Sets the threshold information for a payer

        Parameters:
            - payer_uuid: PayerUuid.

            - request: PayerThreshold.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/fee-schedules/v3/payer-threshold/{payer_uuid}"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PayerThreshold, _response_json)  # type: ignore
        if "errorName" in _response_json:
            if _response_json["errorName"] == "EntityNotFoundError":
                raise EntityNotFoundError(
                    pydantic.parse_obj_as(EntityNotFoundErrorMessage, _response_json["content"])  # type: ignore
                )
        raise ApiError(status_code=_response.status_code, body=_response_json)
