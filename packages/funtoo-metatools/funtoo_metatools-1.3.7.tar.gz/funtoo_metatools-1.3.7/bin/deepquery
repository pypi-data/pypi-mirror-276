#!/usr/bin/python3
#
# This command will show all packages in a category (such as 'dev-perl', which is specified
# as the command-line argument) upon which no other packages depend. It's designed for
# next-release only.
#
# It will then write/mod packages.yaml in ~/repo_tmp/source_trees/kit-fixups so that these
# packages are automatically removed from the packages.yaml. You will need to git add and
# commit these changes -- and the code is careful to write all changes to next/packages.yaml
# as to not mess up 1.4-release.

import os
import sys
from collections import defaultdict

import yaml
from pymongo import MongoClient
from subpop.hub import Hub

from metatools.config.merge import MinimalMergeConfig
from metatools.release import AutoGeneratedKit

hub = Hub()


async def main_thread(debug):
	model = MinimalMergeConfig()
	await model.initialize(
		release="next",
		debug=debug
	)
	mc = MongoClient()
	dd = mc.metatools.deepdive

	# Organize results per kit (key is kit, values are a set of catpkgs in that kit on which nothing else depends):

	kit_to_null_catpkg_map = defaultdict(set)

	# Logic: we will look at all atoms that are in a particular category...
	for atom_in_cat in dd.find({"category": sys.argv[1]}):

		# Logic: for each atom, get the catpkg of that atom, and then do another query to see how many packages in
		#        the entire tree depend on that catpkg.

		dep_on_me = dd.count_documents({"relations": {"$in": [atom_in_cat["catpkg"]]}})

		# Logic: if no packages depend on that catpkg, then add it to a set of catpkgs, organized by kit. We use a
		#        set because since our outer loop queries each atom, we are going to get duplicate catpkgs.

		if dep_on_me == 0:
			kit_to_null_catpkg_map[atom_in_cat["kit"]].add(atom_in_cat["catpkg"])

	# Print out a report showing unused catpkgs, by kit:

	# Get the actual kit objects from metatools, rather than just their name:

	real_kits = {}

	for kit in model.release_yaml.iter_kits(primary=True):
		real_kits[kit.name] = kit
	# TODO: also print the list of not-found-but-could-be-removed items!
	for kit, catpkgs in kit_to_null_catpkg_map.items():
		print(kit)
		if isinstance(real_kits[kit], AutoGeneratedKit):
			found_items = {}
			package_yaml_entries = real_kits[kit].get_kit_items()
			for section, entries in package_yaml_entries:
				entries = set(entries)
				found_catpkgs = catpkgs & entries
				if len(found_catpkgs):
					found_items[section] = found_catpkgs
				catpkgs = catpkgs - found_catpkgs
				if found_catpkgs:
					print(section)
					for catpkg in sorted(list(found_catpkgs)):
						print(f"  {catpkg}")

			# This means -- we found things to remove from packages.yaml:
			if found_items:
				print(f"Found {len(found_items)} items to remove from packages.yaml for {kit}.")
				with open(real_kits[kit].packages_yaml, "r") as f:
					pkg_contents = yaml.safe_load(f)
					new_packages_yaml = []
					for repo in pkg_contents["packages"]:
						for section, pkg_list in repo.items():
							print(f"looking in section {section}")
							if section in found_items:
								model.log.info(f"Found section {section} -- attempting to remove {sorted(list(found_items[section]))}")
								new_packages = set(pkg_list) - found_items[section]
								new_packages_yaml.append({section: sorted(list(new_packages))})
							else:
								new_packages_yaml.append({section: pkg_list})
					pkg_contents["packages"] = new_packages_yaml
				# Attempt to write out to the release-specific packages.yaml file:
				spec_yaml = real_kits[kit].specific_packages_yaml
				if not os.path.isdir(os.path.dirname(spec_yaml)):
					os.makedirs(os.path.dirname(spec_yaml), exist_ok=True)
				with open(real_kits[kit].specific_packages_yaml, "w") as f:
					print(f"Writing new YAML to {real_kits[kit].packages_yaml}")
					yaml.safe_dump(pkg_contents, f)
		else:
			for catpkg in catpkgs:
				print(f"  {catpkg}")


if __name__ == "__main__":
	if hub.LOOP.run_until_complete(main_thread(False)):
		sys.exit(0)
	else:
		sys.exit(1)
