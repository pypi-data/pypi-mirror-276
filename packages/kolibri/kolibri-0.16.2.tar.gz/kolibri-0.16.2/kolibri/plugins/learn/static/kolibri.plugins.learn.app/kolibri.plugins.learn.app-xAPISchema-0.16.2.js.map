{"version":3,"file":"kolibri.plugins.learn.app-xAPISchema-0.16.2.js","mappings":"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","sources":["webpack://kolibri-root/./packages/hashi/src/xAPI/xAPISchema.js"],"sourcesContent":["/**\n * This module creates utilities for validating xAPI statements\n *\n * For more information, see:\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md\n */\nimport 'core-js/features/set';\nimport isArray from 'lodash/isArray';\nimport isBoolean from 'lodash/isBoolean';\nimport isFunction from 'lodash/isFunction';\nimport isNumber from 'lodash/isNumber';\nimport isPlainObject from 'lodash/isPlainObject';\nimport isString from 'lodash/isString';\nimport isUndefined from 'lodash/isUndefined';\nimport { validate as validateUUID, v4 as uuidv4 } from 'uuid';\nimport { parse as parseDuration } from 'iso8601-duration';\nimport { IRI } from 'iri';\nimport dayjs from 'dayjs';\nimport { isLangCode } from 'is-language-code';\nimport {\n  OBJECT_TYPES,\n  ObjectTypeChoices,\n  INTERACTION_TYPES,\n  InteractionTypeChoices,\n  interactionOptionsLookup,\n  OUTER_DELIMITER,\n  INNER_DELIMITER,\n  RANGE_DELIMITER,\n  CMI_INTERACTION,\n} from './xAPIConstants';\n\nconst logging = console; //elsint-disable-line no-console\n\n/*\n * Custom error to trigger when validation fails\n * Use ES5 compatible subclassing for compatibility.\n * Use this instead of a built in error to be sure\n * that validation errors in tests are actually because\n * of failed validation and not code errors.\n */\nexport function xAPIValidationError(message, fileName, lineNumber) {\n  var instance = new Error(message, fileName, lineNumber);\n  instance.name = 'xAPIValidationError';\n  Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(instance, xAPIValidationError);\n  }\n  return instance;\n}\n\nxAPIValidationError.prototype = Object.create(Error.prototype, {\n  constructor: {\n    value: Error,\n    enumerable: false,\n    writable: true,\n    configurable: true,\n  },\n});\n\nif (Object.setPrototypeOf) {\n  Object.setPrototypeOf(xAPIValidationError, Error);\n} else {\n  xAPIValidationError.__proto__ = Error;\n}\n\n/*\n * Utility functions to help with validation\n */\n\n/*\n * Number turns empty string into 0 and so\n * does lodash toNumber - we want to treat\n * blank string differently due to the semantics\n * of the xAPI/SCORM numeric format.\n */\nfunction toNumber(value) {\n  return value === '' ? NaN : Number(value);\n}\n\n/*\n * Helper function to parse the xAPI/SCORM numeric format\n * Can be a single digit, an unbounded range, or a bounded range\n * e.g.:\n * 7 - number 7\n * 7[:] - 7 and up\n * [:]7 - up to and including 7\n * 4[:]7 - 4 to 7 inclusive\n */\nfunction numericValid(r) {\n  const [start, end] = r.split(RANGE_DELIMITER);\n  const startNumber = toNumber(start);\n  // Single number only case, no delimiter used.\n  if (isUndefined(end)) {\n    return !isNaN(startNumber);\n  }\n  // If we have got here, there is a delimiter\n  const endNumber = toNumber(end);\n  if (start === '') {\n    // Range unbounded on the lower end\n    return !isNaN(endNumber);\n  }\n  if (end === '') {\n    // Range unbounded on the upper end\n    return !isNaN(startNumber);\n  }\n  if (!isNaN(startNumber) && !isNaN(endNumber)) {\n    // Both are numbers, so just check that this is\n    // a valid range.\n    return startNumber < endNumber;\n  }\n  // No other success cases, so must have failed.\n  return false;\n}\n\n/*\n * Calculate how many mutually exclusive IFI fields have been defined\n * on an object.\n */\nconst numIFI = o =>\n  Boolean(o.mbox) + Boolean(o.mbox_sha1sum) + Boolean(o.openid) + Boolean(o.account);\n\n/*\n * Validator objects.\n * Most of the validator objects are plain objects with a\n * test and msg method - test returns true or false for whether\n * the attribute passes validation, msg returns the error message\n *\n * test accepts up to three parameters - value, key, and whole object\n * msg accepts up to two parameters - key, and whole object\n * warn - an optional boolean property, if true, this will only log a warning\n *        and not fail validation - useful for properties that MAY be enforced in the spec\n */\n\n/*\n * The first validators are just Javascript Regex objects that have an\n * additional msg method defined on them, so already have the test method\n * defined.\n */\n\nconst mboxRegex = /^mailto:[^@]+@[^@]+$/;\nmboxRegex.msg = attr => `${attr} does not start with mailto: or is not a valid email address`;\n\n// SHA-1 Hashes have a bit length of 160, giving a 40 digit hex\nconst sha1Validator = /^[a-f0-9]{40}$/;\nsha1Validator.msg = attr => `${attr} is not a valid SHA1 sum`;\n\n/*\n * SHA-2 is a family of hash functions:\n * SHA-224 - bit length 224, 56 digit hex\n * SHA-256 - bit length 256, 64 digit hex\n * SHA-384 - bit length 384, 96 digit hex\n * SHA-512 - bit length 512, 128 digit hex\n * SHA-512/224 - bit length 224, 56 digit hex\n * SHA-512/256 - bit length 256, 64 digit hex\n */\nconst sha2Validator = /^([a-f0-9]{56}|[a-f0-9]{64}|[a-f0-9]{96}|[a-f0-9]{128})$/;\nsha2Validator.msg = attr => `${attr} is not a valid SHA2 hash`;\n\n/*\n * Validators for basic Javascript types\n * These will often be used in conjunction with other\n * validators to prevent having to type check in subsequent validation\n */\n\nconst arrayValidator = {\n  test: isArray,\n  msg: attr => `${attr} must be an array`,\n};\n\nconst arrayOrObjectValidator = {\n  test: v => isArray(v) || isPlainObject(v),\n  msg: attr => `${attr} must be an array or object`,\n};\n\nconst booleanValidator = {\n  test: isBoolean,\n  msg: attr => `${attr} must be a boolean`,\n};\n\nconst numberValidator = {\n  test: isNumber,\n  msg: attr => `${attr} must be a number`,\n};\n\nconst objectValidator = {\n  test: isPlainObject,\n  msg: attr => `${attr} must be an object`,\n};\n\nconst stringValidator = {\n  test: isString,\n  msg: attr => `${attr} must be a string`,\n};\n\n/*\n * Additional 'primitive' types defined here:\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#special-data\n * and in various ietf.org RFCs\n */\n\nconst mimeTypeValidator = /\\w+\\/[-.\\w]+(?:\\+[-.\\w]+)?/;\nmimeTypeValidator.msg = attr => `${attr} is not a valid mimetype`;\n\nconst languageValidator = {\n  test: v => isLangCode(v).res,\n  msg: (attr, o) => `${attr} is not a valid language code because: ${isLangCode(o[attr]).message}`,\n};\n\nconst languageMapValidator = {\n  test: v => Object.entries(v).every(([k, s]) => isLangCode(k).res && isString(s)),\n  msg: attr => `${attr} is not a valid LanguageMap`,\n};\n\nconst IRIValidator = {\n  test: v => {\n    const iri = new IRI(v);\n    return iri.scheme() && iri.hierpart() && iri.authority();\n  },\n  msg: attr => `${attr} is not a valid IRI`,\n};\n\nconst IRLValidator = {\n  test: v => {\n    const iri = new IRI(v);\n    return (iri.scheme() && iri.hierpart() && iri.authority()) || iri.path();\n  },\n  msg: attr => `${attr} is not a valid IRL`,\n};\n\nconst durationValidator = {\n  test: v => {\n    try {\n      parseDuration(v);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  },\n  msg: attr => `${attr} must be an ISO 8601 duration`,\n};\n\nconst timestampValidator = {\n  test: v => {\n    const d = dayjs(v);\n    return d.isValid();\n  },\n  msg: attr => `${attr} must be an ISO 8601 timestamp`,\n};\n\nconst UUIDValidator = {\n  test: validateUUID,\n  msg: attr => `${attr} must be a valid UUID`,\n};\n\n/*\n * These validators are specific to encoding SCORM based CMI interaction types.\n * Detailed here: https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#interaction-activities\n */\n\nconst interactionTypeValidator = {\n  test: v => InteractionTypeChoices.has(v),\n  msg: attr => `${attr} was set as an invalid interaction type`,\n};\n\n/*\n * Some interaction types do not take any other parameters\n * and the specification enforces that these should not be passed\n * alongside these types - this validator enforces that.\n */\nconst noOptionsValidator = {\n  test: (v, k, o) => {\n    return interactionOptionsLookup[k].has(o.interactionType);\n  },\n  msg: (key, o) => `${key} specified but ${o.interactionType} does not support it`,\n};\n\n/*\n * This validates the correctResponses property - ensuring that\n * correctResponses are accurate when compared to the available\n * responses to the interaction.\n */\nconst correctResponsesValidator = {\n  warn: true,\n  test: (v, k, o) => {\n    const interactionType = o.interactionType;\n    const correctResponsesPattern = o.correctResponsesPattern;\n    if (interactionType === INTERACTION_TYPES.TRUE_FALSE) {\n      return correctResponsesPattern.every(r => r === 'true' || r === 'false');\n    }\n    if (\n      interactionType === INTERACTION_TYPES.CHOICE ||\n      interactionType === INTERACTION_TYPES.SEQUENCING\n    ) {\n      const choices = o.choices;\n      const choiceIds = new Set(choices.map(c => c.id));\n      return correctResponsesPattern.every(r => {\n        const ids = r.split(OUTER_DELIMITER);\n        return ids.every(id => choiceIds.has(id));\n      });\n    }\n    if (interactionType === INTERACTION_TYPES.MATCHING) {\n      const source = o.source;\n      const target = o.target;\n      const sourceIds = new Set(source.map(c => c.id));\n      const targetIds = new Set(target.map(c => c.id));\n      return correctResponsesPattern.every(r => {\n        const pairs = r.split(OUTER_DELIMITER);\n        return pairs.every(pair => {\n          const [s, t] = pair.split(INNER_DELIMITER);\n          return sourceIds.has(s) && targetIds.has(t);\n        });\n      });\n    }\n    if (interactionType === INTERACTION_TYPES.PERFORMANCE) {\n      const steps = o.steps;\n      const stepIds = new Set(steps.map(c => c.id));\n      return correctResponsesPattern.every(r => {\n        const pairs = r.split(OUTER_DELIMITER);\n        return pairs.every(pair => {\n          const [s] = pair.split(INNER_DELIMITER);\n          return stepIds.has(s);\n        });\n      });\n    }\n    if (interactionType === INTERACTION_TYPES.LIKERT) {\n      const scale = o.scale;\n      const scaleIds = new Set(scale.map(c => c.id));\n      return correctResponsesPattern.every(r => scaleIds.has(r));\n    }\n    if (interactionType === INTERACTION_TYPES.NUMERIC) {\n      return correctResponsesPattern.every(numericValid);\n    }\n    return true;\n  },\n  msg: (key, o) => {\n    const interactionType = o.interactionType;\n    if (interactionType === INTERACTION_TYPES.TRUE_FALSE) {\n      return 'true-false must take either true or false as the answer';\n    }\n    if (\n      interactionType === INTERACTION_TYPES.CHOICE ||\n      interactionType === INTERACTION_TYPES.SEQUENCING\n    ) {\n      return `${interactionType} must only use choice ids from the item`;\n    }\n    if (\n      interactionType === INTERACTION_TYPES.FILL_IN ||\n      interactionType === INTERACTION_TYPES.LONG_FILL_IN\n    ) {\n      return `${interactionType} must have no non blank answers`;\n    }\n    if (interactionType === INTERACTION_TYPES.MATCHING) {\n      return 'matching must only use source and target ids from the item';\n    }\n    if (interactionType === INTERACTION_TYPES.PERFORMANCE) {\n      return 'performance must only use step ids and fill-in or numeric responses';\n    }\n    if (interactionType === INTERACTION_TYPES.LIKERT) {\n      return `${interactionType} must only use scale ids from the item`;\n    }\n    if (interactionType === INTERACTION_TYPES.NUMERIC) {\n      return `${interactionType} must have valid numeric responses`;\n    }\n  },\n};\n\n/*\n * Validators specific to enforcing the correct objectType for objects\n * and ensuring that appropriate parameters are set depending on the objectType\n */\nconst objectTypeValidator = {\n  test: v => isUndefined(v.objectType) || ObjectTypeChoices.has(v.objectType),\n  msg: () => 'objectType must either be undefined or an allowed value',\n};\n\nconst noSubStatement = {\n  test: v => !v.objectType || v.objectType !== OBJECT_TYPES.SUBSTATEMENT,\n  msg: () => 'object cannot be a SubStatement',\n};\n\nconst authorityTypeValidator = {\n  test: v => v.objectType === OBJECT_TYPES.AGENT || v.objectType === OBJECT_TYPES.GROUP,\n  msg: () => 'authority must either be an Agent or a Group',\n};\n\nconst authorityOAuthValidator = {\n  test: v => v.objectType !== OBJECT_TYPES.GROUP || v.member.length === 2,\n  msg: () => 'if authority is a group, must specify two member Agents',\n};\n\nconst contextPropertyValidator = {\n  /*\n   * The \"revision\" Context property MUST only be used if the Statement's Object is an Activity.\n   * The \"platform\" Context property MUST only be used if the Statement's Object is an Activity.\n   */\n  test: (v, k, o) => {\n    // Object is an activity if it has no defined objectType or explicitly set as one\n    if (isUndefined(v.objectType) || v.objectType === OBJECT_TYPES.ACTIVITY) {\n      // In this case, no further validation needed.\n      return true;\n    }\n    // Check that context does not have either for these values\n    return (\n      isUndefined(o.context) || (isUndefined(o.context.revision) && isUndefined(o.context.platform))\n    );\n  },\n};\n\n/*\n * Enforce no whitespace\n */\nconst noWhiteSpaceValidator = {\n  test: v => !/\\s/.test(v),\n  msg: attr => `${attr} must not contain whitespace`,\n};\n\n/*\n * Score object validators\n */\nconst scaledValidator = {\n  test: v => -1 <= v && 1 >= v,\n  msg: attr => `${attr} must be in the range -1 to 1 inclusive`,\n};\n\nconst minValidator = {\n  test: (v, k, o) => isUndefined(o.max) || v < o.max,\n  msg: () => `min must be less than max`,\n};\n\nconst maxValidator = {\n  test: (v, k, o) => isUndefined(o.min) || v > o.min,\n  msg: () => `max must be greater than min`,\n};\n\nconst rawMinValidator = {\n  test: (v, k, o) => isUndefined(o.min) || v >= o.min,\n  msg: () => 'raw must be greater than or equal to min',\n};\n\nconst rawMaxValidator = {\n  test: (v, k, o) => isUndefined(o.max) || v <= o.max,\n  msg: () => 'raw must be less than or equal to max',\n};\n\n/*\n * Validation of the version property of the Statement object\n */\nconst versionValidator = {\n  test: v => {\n    const parts = v.split('.').map(toNumber);\n    const [maj, min, pat] = parts;\n    if (parts.length === 3 && !isNaN(maj) && !isNaN(min) && !isNaN(pat)) {\n      return maj === 1 && min === 0;\n    }\n    return false;\n  },\n  msg: () => 'version must begin with 1.0 and be a semantic version',\n};\n\n/*\n * Use this to enforce properties that are explicitly _not_ allowed\n */\nconst notAllowed = {\n  test: () => false,\n  msg: attr => `${attr} was set but is not allowed`,\n};\n\n/*\n * Helper class to generate a validator that enforces a specific value\n */\nclass EnforceValue {\n  constructor(value) {\n    this.value = value;\n  }\n\n  test(v) {\n    return v === this.value;\n  }\n\n  msg(attr, obj) {\n    return `${attr} value did not match ${this.value} received ${obj[attr]}`;\n  }\n}\n\n/*\n * This is the main class that drives validation.\n * Its constructor takes a single argument which is the specification\n * of the schema that is going to be validated against.\n * It has a single method 'clean' that iterates over this specification\n * and checks the passed in object against this specification.\n *\n * A specification is in this format:\n *\n * {\n *   keyname: {\n *     required:   Boolean|Function\n *                 whether this keyname is required or not, defaults to false,\n *                 if it is a Function it will be called with arguments:\n *                 value, key, object and should return a Boolean result.\n *     validators: Array\n *                 an Array of validators - objects with methods test and msg\n *                 these are applied in the order specified in the Array,\n *                 and an xAPIValidationError will be thrown as soon as one\n *                 fails.\n *     schema:     Schema|Function\n *                 A Schema to use for further cleaning. If it is a function,\n *                 it will be invoked with arguments value, key, object and\n *                 should return a Schema object. The Schema object will then\n *                 have its clean method called either on the value directly,\n *                 or if the value is an Array, it is called on each object\n *                 in the Array and an Array of results returned.\n *     clean:      Function that takes the output of any Schema based cleaning\n *                 and allows that to be updated. This is currently only used\n *                 to turn a single object into an array with one object to\n *                 handle legacy data requirements in xAPI:\n *                 https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#requirements-11\n *     default:    Function\n *                 If the value is not found on the object, this function will\n *                 be invoked to create the value.\n *   }\n * }\n *\n *\n */\nclass Schema {\n  constructor(spec) {\n    this.spec = spec;\n  }\n  clean(obj) {\n    const output = {};\n    for (const key in this.spec) {\n      const keySpec = this.spec[key];\n      let required = keySpec.required;\n      if (isFunction(required)) {\n        required = required(obj);\n      }\n      if (required && isUndefined(obj[key])) {\n        throw new xAPIValidationError(`${key} required but not found`);\n      }\n      if (!isUndefined(obj[key])) {\n        const validators = keySpec.validators || [];\n        for (let i = 0; i < validators.length; i++) {\n          const v = validators[i];\n          if (!v.test(obj[key], key, obj)) {\n            const msg = v.msg(key, obj);\n            if (v.warn) {\n              logging.warn(msg);\n            } else {\n              throw new xAPIValidationError(msg);\n            }\n          }\n        }\n        let schema = keySpec.schema;\n        if (isFunction(schema)) {\n          schema = schema(obj[key], key, obj);\n        }\n        if (schema && schema instanceof Schema) {\n          try {\n            if (isArray(obj[key])) {\n              output[key] = obj[key].map(o => schema.clean(o));\n            } else {\n              output[key] = schema.clean(obj[key]);\n            }\n          } catch (e) {\n            // Catch errors and rethrow to add path context to error message\n            throw new xAPIValidationError(`in ${key}: ${e.message}`);\n          }\n        } else {\n          output[key] = obj[key];\n        }\n        if (keySpec.clean) {\n          output[key] = keySpec.clean(output[key]);\n        }\n      } else if (keySpec.default && isFunction(keySpec.default)) {\n        output[key] = keySpec.default();\n      }\n    }\n    return output;\n  }\n}\n\n/*\n * Helper function to create a specification for IFI validation\n * which is used both for Agent and Group objects.\n * More info on IFI fields here:\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#inversefunctional\n */\nfunction IFISpecFactory(required) {\n  let ifiValidator;\n  if (required) {\n    ifiValidator = {\n      test: (v, k, o) => numIFI(o) === 1,\n      msg: () => 'Did not supply exactly one IFI',\n    };\n  } else {\n    ifiValidator = {\n      test: (v, k, o) => numIFI(o) < 2,\n      msg: () => 'Supplied more than one IFI',\n    };\n  }\n  return {\n    mbox: {\n      required: o => !o.mbox_sha1sum && !o.openid && !o.account,\n      validators: [ifiValidator, stringValidator, mboxRegex],\n    },\n    mbox_sha1sum: {\n      required: o => !o.mbox && !o.openid && !o.account,\n      validators: [ifiValidator, stringValidator, sha1Validator],\n    },\n    openid: {\n      required: o => !o.mbox && !o.mbox_sha1sum && !o.account,\n      validators: [ifiValidator, stringValidator],\n    },\n    account: {\n      required: o => !o.mbox && !o.mbox_sha1sum && !o.openid,\n      validators: [ifiValidator],\n      schema: new Schema({\n        homePage: {\n          required: true,\n          validators: [stringValidator],\n        },\n        name: {\n          required: true,\n          validators: [stringValidator],\n        },\n      }),\n    },\n  };\n}\n\n/*\n * Schema definitions for Actor objects, can either be an Agent\n * for an individual or Group for multiple users.\n */\n\nexport const Agent = new Schema({\n  objectType: {\n    validators: [stringValidator, new EnforceValue(OBJECT_TYPES.AGENT)],\n  },\n  name: {\n    validators: [stringValidator],\n  },\n  ...IFISpecFactory(true),\n});\n\nexport const Group = new Schema({\n  objectType: {\n    required: true,\n    validators: [stringValidator, new EnforceValue(OBJECT_TYPES.GROUP)],\n  },\n  member: {\n    required: obj => !numIFI(obj),\n    validators: [arrayValidator],\n    schema: Agent,\n  },\n  name: {\n    validators: [stringValidator],\n  },\n  ...IFISpecFactory(false),\n});\n\nconst Actor = o => (o.objectType === OBJECT_TYPES.GROUP ? Group : Agent);\n\n/*\n * Verb definition:\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#243-verb\n */\nexport const Verb = new Schema({\n  id: {\n    required: true,\n    validators: [stringValidator, IRIValidator],\n  },\n  display: {\n    validators: [objectValidator],\n  },\n});\n\n/*\n * Schema definitions for Object types not already defined above:\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#244-object\n */\n\n/*\n * Used to define data about responses in CMI interaction types:\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#interaction-components\n */\nconst InteractionComponent = new Schema({\n  id: {\n    required: true,\n    validators: [stringValidator, noWhiteSpaceValidator],\n  },\n  description: {\n    validators: [objectValidator, languageMapValidator],\n  },\n});\n\n/*\n * ActivityDefinition Schema, used for defining\n * activities, with specific additional information\n * for SCORM CMI activities:\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#activity-definition\n */\nexport const ActivityDefinition = new Schema({\n  name: {\n    validators: [objectValidator, languageMapValidator],\n  },\n  description: {\n    validators: [objectValidator, languageMapValidator],\n  },\n  type: {\n    validators: [stringValidator, IRIValidator],\n  },\n  moreInfo: {\n    validators: [stringValidator, IRLValidator],\n  },\n  extensions: {\n    validators: [objectValidator],\n  },\n  interactionType: {\n    required: o => o.type === CMI_INTERACTION,\n    validators: [stringValidator, interactionTypeValidator],\n  },\n  choices: {\n    schema: InteractionComponent,\n    validators: [noOptionsValidator, arrayValidator],\n    required: obj =>\n      obj.interactionType === INTERACTION_TYPES.CHOICE ||\n      obj.interactionType === INTERACTION_TYPES.SEQUENCING,\n  },\n  source: {\n    schema: InteractionComponent,\n    validators: [noOptionsValidator, arrayValidator],\n    required: obj => obj.interactionType === INTERACTION_TYPES.MATCHING,\n  },\n  target: {\n    schema: InteractionComponent,\n    validators: [noOptionsValidator, arrayValidator],\n    required: obj => obj.interactionType === INTERACTION_TYPES.MATCHING,\n  },\n  steps: {\n    schema: InteractionComponent,\n    validators: [noOptionsValidator, arrayValidator],\n    required: obj => obj.interactionType === INTERACTION_TYPES.PERFORMANCE,\n  },\n  scale: {\n    schema: InteractionComponent,\n    validators: [noOptionsValidator, arrayValidator],\n    required: obj => obj.interactionType === INTERACTION_TYPES.LIKERT,\n  },\n  correctResponsesPattern: {\n    validators: [arrayValidator, correctResponsesValidator],\n  },\n});\n\n/*\n * Activity Schema definition - used to describe activities that\n * statements are about.\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#2441-when-the-objecttype-is-activity\n */\nexport const Activity = new Schema({\n  id: {\n    validators: [stringValidator, IRIValidator],\n  },\n  objectType: {\n    validators: [stringValidator, new EnforceValue(OBJECT_TYPES.ACTIVITY)],\n  },\n  definition: {\n    schema: ActivityDefinition,\n  },\n});\n\n/*\n * StatementRef Schema - used to refer to another statement\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#statement-references\n */\nexport const StatementRef = new Schema({\n  id: {\n    validators: [UUIDValidator],\n  },\n  objectType: {\n    validators: [stringValidator, new EnforceValue(OBJECT_TYPES.STATEMENTREF)],\n  },\n});\n\n/*\n * Helper function to return the correct Schema object depending\n * on the specified objectType value.\n */\nexport const ObjectSchema = o => {\n  const objectType = o.objectType;\n  if (!objectType || objectType === OBJECT_TYPES.ACTIVITY) {\n    return Activity;\n  }\n  if (objectType === OBJECT_TYPES.AGENT) {\n    return Agent;\n  }\n  if (objectType === OBJECT_TYPES.GROUP) {\n    return Group;\n  }\n  if (objectType === OBJECT_TYPES.STATEMENTREF) {\n    return StatementRef;\n  }\n  if (objectType === OBJECT_TYPES.SUBSTATEMENT) {\n    return SubStatement;\n  }\n};\n\n/*\n * Score Schema - used to describe the score of a result in a statement.\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#2451-score\n */\nexport const Score = new Schema({\n  scaled: {\n    validators: [numberValidator, scaledValidator],\n  },\n  min: {\n    validators: [numberValidator, minValidator],\n  },\n  max: {\n    validators: [numberValidator, maxValidator],\n  },\n  raw: {\n    validators: [numberValidator, rawMinValidator, rawMaxValidator],\n  },\n});\n\n/*\n * Result Schema - used to describe results from interactions.\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#245-result\n */\nexport const Result = new Schema({\n  score: {\n    schema: Score,\n  },\n  success: {\n    validators: [booleanValidator],\n  },\n  completion: {\n    validators: [booleanValidator],\n  },\n  response: {\n    validators: [stringValidator],\n  },\n  duration: {\n    validators: [durationValidator],\n  },\n  extensions: {\n    validators: [objectValidator],\n  },\n});\n\n// Helper function to return an object wrapped in an array if not already an array\nconst coerceToArray = o => (isArray(o) ? o : [o]);\n\n/*\n * Context Schema - used to provide additional context to a Statement.\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#246-context\n */\nexport const Context = new Schema({\n  registration: {\n    validators: [UUIDValidator],\n  },\n  instructor: {\n    schema: Agent,\n  },\n  team: {\n    group: Group,\n  },\n  contextActivities: {\n    schema: new Schema({\n      parent: {\n        schema: Activity,\n        validators: [arrayOrObjectValidator],\n        clean: coerceToArray,\n      },\n      grouping: {\n        schema: Activity,\n        validators: [arrayOrObjectValidator],\n        clean: coerceToArray,\n      },\n      category: {\n        schema: Activity,\n        validators: [arrayOrObjectValidator],\n        clean: coerceToArray,\n      },\n      other: {\n        schema: Activity,\n        validators: [arrayOrObjectValidator],\n        clean: coerceToArray,\n      },\n    }),\n  },\n  revision: {\n    validators: [stringValidator],\n  },\n  platform: {\n    validators: [stringValidator],\n  },\n  language: {\n    validators: [stringValidator, languageValidator],\n  },\n  statement: {\n    schema: StatementRef,\n  },\n  extensions: {\n    validators: [objectValidator],\n  },\n});\n\n/*\n * Attachment Schema - used to describe information about file\n * attachments associated with the statement.\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#2411-attachments\n */\nexport const Attachment = new Schema({\n  usageType: {\n    required: true,\n    validators: [IRIValidator],\n  },\n  display: {\n    required: true,\n    validators: [objectValidator, languageMapValidator],\n  },\n  description: {\n    validators: [objectValidator, languageMapValidator],\n  },\n  contentType: {\n    required: true,\n    validators: [stringValidator, mimeTypeValidator],\n  },\n  length: {\n    required: true,\n    validators: [numberValidator],\n  },\n  sha2: {\n    required: true,\n    validators: [stringValidator, sha2Validator],\n  },\n  fileUrl: {\n    validators: [stringValidator, IRLValidator],\n  },\n});\n\n/* SubStatement Schema - used to create a statement that is nested inside another\n * another statement as an object.\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#substatements\n */\nexport const SubStatement = new Schema({\n  id: {\n    validators: [notAllowed],\n  },\n  objectType: {\n    required: true,\n    validators: [new EnforceValue(OBJECT_TYPES.SUBSTATEMENT)],\n  },\n  actor: {\n    required: true,\n    schema: Actor,\n  },\n  verb: {\n    required: true,\n    schema: Verb,\n  },\n  object: {\n    required: true,\n    validators: [objectTypeValidator, noSubStatement],\n    schema: ObjectSchema,\n  },\n  result: {\n    schema: Result,\n  },\n  context: {\n    schema: Context,\n  },\n  timestamp: {\n    validators: [timestampValidator],\n  },\n  attachments: {\n    schema: Attachment,\n    validators: [arrayValidator],\n  },\n  stored: {\n    validators: [notAllowed],\n  },\n  version: {\n    validators: [notAllowed],\n  },\n  authority: {\n    validators: [notAllowed],\n  },\n});\n\n/*\n * Statement Schema - the top level object and main entry\n * point for validation.\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#statements\n */\nexport const Statement = new Schema({\n  id: {\n    validators: [UUIDValidator],\n    default: uuidv4,\n  },\n  actor: {\n    required: true,\n    schema: Actor,\n  },\n  verb: {\n    required: true,\n    schema: Verb,\n  },\n  object: {\n    required: true,\n    validators: [objectTypeValidator, contextPropertyValidator],\n    schema: ObjectSchema,\n  },\n  result: {\n    schema: Result,\n  },\n  context: {\n    schema: Context,\n  },\n  timestamp: {\n    validators: [timestampValidator],\n  },\n  // We deliberately exclude the stored value here as it should only be supplied by the LRS\n  // so we ignore anything coming in from the statement creator - this will then be set either\n  // by us in the client side, or on the server when the statement is saved.\n  authority: {\n    schema: Actor,\n    validators: [authorityTypeValidator, authorityOAuthValidator],\n  },\n  version: {\n    validators: [stringValidator, versionValidator],\n    default: () => '1.0.0',\n  },\n  attachments: {\n    schema: Attachment,\n    validators: [arrayValidator],\n  },\n});\n"],"names":["logging","console","xAPIValidationError","message","fileName","lineNumber","instance","Error","name","Object","setPrototypeOf","getPrototypeOf","this","captureStackTrace","toNumber","value","NaN","Number","numericValid","r","_r$split2","_slicedToArray","split","RANGE_DELIMITER","start","end","startNumber","isUndefined","isNaN","endNumber","prototype","create","constructor","enumerable","writable","configurable","__proto__","numIFI","o","Boolean","mbox","mbox_sha1sum","openid","account","mboxRegex","msg","attr","concat","sha1Validator","sha2Validator","arrayValidator","test","isArray","arrayOrObjectValidator","v","isPlainObject","booleanValidator","isBoolean","numberValidator","isNumber","objectValidator","stringValidator","isString","mimeTypeValidator","languageValidator","isLangCode","res","languageMapValidator","entries","every","_ref","_ref2","k","s","IRIValidator","iri","IRI","scheme","hierpart","authority","IRLValidator","path","durationValidator","parseDuration","e","timestampValidator","dayjs","isValid","UUIDValidator","validateUUID","interactionTypeValidator","InteractionTypeChoices","has","noOptionsValidator","interactionOptionsLookup","interactionType","key","correctResponsesValidator","warn","correctResponsesPattern","INTERACTION_TYPES","TRUE_FALSE","CHOICE","SEQUENCING","choices","choiceIds","Set","map","c","id","OUTER_DELIMITER","MATCHING","source","target","sourceIds","targetIds","pair","_pair$split2","INNER_DELIMITER","t","PERFORMANCE","steps","stepIds","LIKERT","scale","scaleIds","NUMERIC","FILL_IN","LONG_FILL_IN","objectTypeValidator","objectType","ObjectTypeChoices","noSubStatement","OBJECT_TYPES","SUBSTATEMENT","authorityTypeValidator","AGENT","GROUP","authorityOAuthValidator","member","length","contextPropertyValidator","ACTIVITY","context","revision","platform","minValidator","max","maxValidator","min","rawMinValidator","rawMaxValidator","versionValidator","parts","_parts","maj","pat","notAllowed","EnforceValue","_classCallCheck","_createClass","obj","Schema","spec","_this","output","_loop","keySpec","required","isFunction","default","validators","i","schema","clean","IFISpecFactory","ifiValidator","homePage","Agent","_objectSpread","Group","Actor","Verb","display","InteractionComponent","description","ActivityDefinition","type","moreInfo","extensions","CMI_INTERACTION","Activity","definition","StatementRef","STATEMENTREF","ObjectSchema","SubStatement","Score","scaled","raw","Result","score","success","completion","response","duration","coerceToArray","Context","registration","instructor","team","group","contextActivities","parent","grouping","category","other","language","statement","Attachment","usageType","contentType","sha2","fileUrl","actor","verb","object","result","timestamp","attachments","stored","version","Statement","uuidv4"],"sourceRoot":""}