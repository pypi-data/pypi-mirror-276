{"guide": {"name": "dynamic-apps-with-render-decorator", "category": "building-with-blocks", "pretty_category": "Building With Blocks", "guide_index": 4, "absolute_index": 18, "pretty_name": "Dynamic Apps With Render Decorator", "content": "# Dynamic Apps with the Render Decorator\n\nThe components and event listeners you define in a Blocks so far have been fixed - once the demo was launched, new components and listeners could not be added, and existing one could not be removed. \n\nThe `@gr.render` decorator introduces the ability to dynamically change this. Let's take a look. \n\n## Dynamic Number of Components\n\nIn the example below, we will create a variable number of Textboxes. When the user edits the input Textbox, we create a Textbox for each letter in the input. Try it out below:\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    input_text = gr.Textbox(label=\"input\")\n\n    @gr.render(inputs=input_text)\n    def show_split(text):\n        if len(text) == 0:\n            gr.Markdown(\"## No Input Provided\")\n        else:\n            for letter in text:\n                gr.Textbox(letter)\n\ndemo.launch()\n```\n<gradio-app space='gradio/render_split_simple'></gradio-app>\n\nSee how we can now create a variable number of Textboxes using our custom logic - in this case, a simple `for` loop. The `@gr.render` decorator enables this with the following steps:\n\n1. Create a function and attach the @gr.render decorator to it.\n2. Add the input components to the `inputs=` argument of @gr.render, and create a corresponding argument in your function for each component. This function will automatically re-run on any change to a component.\n3. Add all components inside the function that you want to render based on the inputs.\n\nNow whenever the inputs change, the funciton re-runs, and replaces the components created from the previous funciton run with the latest run. Pretty straightforward! Let's add a little more complexity to this app:\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    input_text = gr.Textbox(label=\"input\")\n    mode = gr.Radio([\"textbox\", \"button\"], value=\"textbox\")\n\n    @gr.render(inputs=[input_text, mode], triggers=[input_text.submit])\n    def show_split(text, mode):\n        if len(text) == 0:\n            gr.Markdown(\"## No Input Provided\")\n        else:\n            for letter in text:\n                if mode == \"textbox\":\n                    gr.Textbox(letter)\n                else:\n                    gr.Button(letter)\n\ndemo.launch()\n```\n<gradio-app space='gradio/render_split'></gradio-app>\n\nBy default, `@gr.render` re-runs are triggered by the `.load` listener to the app and the `.change` listener to any input component provided. We can override this by explicitly setting the triggers in the decorator, as we have in this app to only trigger on `input_text.submit` instead. \nIf you are setting custom triggers, and you also want an automatic render at the start of the app, make sure to add `demo.load` to your list of triggers.\n\n## Dynamic Event Listeners\n\nIf you're creating components, you probably want to attach event listeners to them as well. Let's take a look at an example that takes in a variable number of Textbox as input, and merges all the text into a single box.\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    text_count = gr.State(1)\n    add_btn = gr.Button(\"Add Box\")\n    add_btn.click(lambda x: x + 1, text_count, text_count)\n\n    @gr.render(inputs=text_count)\n    def render_count(count):\n        boxes = []\n        for i in range(count):\n            box = gr.Textbox(key=i, label=f\"Box {i}\")\n            boxes.append(box)\n\n        def merge(*args):\n            return \" \".join(args)\n        \n        merge_btn.click(merge, boxes, output)\n\n\n    merge_btn = gr.Button(\"Merge\")\n    output = gr.Textbox(label=\"Merged Output\")\n\ndemo.launch()\n```\n<gradio-app space='gradio/render_merge_simple'></gradio-app>\n\nLet's take a look at what's happening here:\n\n1. The state variable `text_count` is keeping track of the number of Textboxes to create. By clicking on the Add button, we increase `text_count` which triggers the render decorator.\n2. Note that in every single Textbox we create in the render function, we explicitly set a `key=` argument. This key allows us to preserve the value of this Component between re-renders. If you type in a value in a textbox, and then click the Add button, all the Textboxes re-render, but their values aren't cleared because the `key=` maintains the the value of a Component across a render.\n3. We've stored the Textboxes created in a list, and provide this list as input to the merge button event listener. Note that **all event listeners that use Components created inside a render function must also be defined inside that render function**. The event listener can still reference Components outside the render function, as we do here by referencing `merge_btn` and `output` which are both defined outside the render function.\n\nJust as with Components, whenever a function re-renders, the event listeners created from the previous render are cleared and the new event listeners from the latest run are attached. \n\nThis allows us to create highly customizable and complex interactions! Take a look at the example below, which spices up the previous example with a lot more event listeners:\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    text_count = gr.Slider(1, 5, step=1, label=\"Textbox Count\")\n\n    @gr.render(inputs=text_count)\n    def render_count(count):\n        boxes = []\n        for i in range(count):\n            box = gr.Textbox(key=i, label=f\"Box {i}\")                \n            boxes.append(box)\n\n        def merge(*args):\n            return \" \".join(args)\n        \n        merge_btn.click(merge, boxes, output)\n\n        def clear():\n            return [\"\"] * count\n                \n        clear_btn.click(clear, None, boxes)\n\n        def countup():\n            return [i for i in range(count)]\n        \n        count_btn.click(countup, None, boxes, queue=False)\n\n    with gr.Row():\n        merge_btn = gr.Button(\"Merge\")\n        clear_btn = gr.Button(\"Clear\")\n        count_btn = gr.Button(\"Count\")\n        \n    output = gr.Textbox()\n\ndemo.launch()\n```\n<gradio-app space='gradio/render_merge'></gradio-app>\n", "tags": [], "spaces": [], "url": "/guides/dynamic-apps-with-render-decorator/", "contributor": null}}