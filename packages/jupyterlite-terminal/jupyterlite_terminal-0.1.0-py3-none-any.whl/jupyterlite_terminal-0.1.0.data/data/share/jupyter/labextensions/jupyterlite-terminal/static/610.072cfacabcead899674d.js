"use strict";(self.webpackChunk_jupyterlite_terminal=self.webpackChunk_jupyterlite_terminal||[]).push([[610],{610:(e,s,t)=>{t.r(s),t.d(s,{default:()=>r});const n=new(t(262).Token)("@jupyterlite/terminal:ITerminals");var a=t(39),i=t(155);class o{constructor(e){this._name=e.name,this._fs=new a.JupyterFileSystem(e.contentsManager),console.log("==> new Terminal",this._name,this._fs)}get name(){return this._name}async wsConnect(e){console.log("==> Terminal.wsConnect",e),new i.Server(e).on("connection",(async e=>{console.log("==> server connection",this,e),this._shell=new a.Shell(this._fs,(async s=>{console.log("==> recv from shell:",s);const t=JSON.stringify(["stdout",s]);e.send(t)})),console.log("==> shell",this._shell),e.on("message",(async e=>{const s=JSON.parse(e);console.log("==> socket message",s);const t=s[0],n=s.slice(1);if("stdin"===t)await this._shell.input(n[0]);else if("set_size"===t){const e=n[0],s=n[1];await this._shell.setSize(e,s)}})),e.on("close",(async()=>{console.log("==> socket close")})),e.on("error",(async()=>{console.log("==> socket error")}));const s=JSON.stringify(["setup"]);console.log("==> Returning handshake via socket",s),e.send(s),await this._shell.start()}))}}class l{constructor(e,s){this._terminals=new Map,this._wsUrl=e,this._contentsManager=s,console.log("==> Terminals.constructor",this._wsUrl,this._contentsManager)}async list(){const e=[...this._terminals.values()].map((e=>({name:e.name})));return console.log("==> Terminals.list",e),e}async startNew(){const e=this._nextAvailableName();console.log("==> Terminals.new",e);const s=new o({name:e,contentsManager:this._contentsManager});this._terminals.set(e,s);const t=`${this._wsUrl}terminals/websocket/${e}`;return await s.wsConnect(t),{name:e}}_nextAvailableName(){for(let e=1;;++e){const s=`${e}`;if(!this._terminals.has(s))return s}}}const r=[{id:"@jupyterlite/terminal:plugin",description:"A terminal for JupyterLite",autoStart:!0,provides:n,activate:async e=>{console.log("JupyterLab extension @jupyterlite/terminal:plugin is activated!");const{serviceManager:s}=e,{contents:t,serverSettings:n,terminals:a}=s;return console.log("terminals available:",a.isAvailable()),console.log("terminals ready:",a.isReady),console.log("terminals active:",a.isActive),await a.ready,console.log("terminals ready after await:",a.isReady),new l(n.wsUrl,t)}},{id:"@jupyterlite/terminal:routes-plugin",autoStart:!0,requires:[n],activate:(e,s)=>{console.log("JupyterLab extension @jupyterlite/terminal:routes-plugin is activated!",s),e.router.get("/api/terminals",(async e=>{const t=s.list();return new Response(JSON.stringify(t))})),e.router.post("/api/terminals",(async e=>{const t=await s.startNew();return new Response(JSON.stringify(t))}))}}]}}]);