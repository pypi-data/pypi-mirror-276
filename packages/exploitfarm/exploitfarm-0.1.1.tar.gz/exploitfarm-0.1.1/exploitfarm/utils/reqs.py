import requests, os
from uuid import UUID
from typing import Dict, Any
from exploitfarm.utils.config import ClientConfig
import orjson

HTTP_TIMEOUT = float(os.getenv("XFARM_HTTP_TIMEOUT", 5))
PATH_OFFSET = os.getenv("XFARM_PATH_OFFSET", "/api")

def get_url(path:str, config: ClientConfig|None = None) -> str:
    protocol = "https" if config.server.https else "http"
    result = f"{protocol}://{config.server.address}:{config.server.port}"+os.path.join("/", PATH_OFFSET, path[1:] if path.startswith('/') else path)
    if result.endswith("/"): result = result[:-1]
    return result

def jsonify(data: Any) -> str:
    return orjson.loads(orjson.dumps(data))

def get_session(auth:str|None|ClientConfig = None) -> requests.Session:
    res = requests.Session()
    if auth is not None:
        if isinstance(auth, str):
            res.headers.update({"Authorization": "Bearer "+auth})
        elif isinstance(auth, ClientConfig) and auth.server.auth_key is not None:
            res.headers.update({"Authorization": "Bearer "+auth.server.auth_key})
    return res

class ReqsError(Exception):pass

def requests_check(res: Dict) -> Any:
    if res["status"] != "ok":
        raise ReqsError(res["message"])
    else:
        return res["response"]

class Reqs:
    def __init__(self, config: ClientConfig):
        self.config = config
        self.session = get_session(config)
    
    def refresh_session(self, auth:str|ClientConfig|None = None):
        self.session = get_session(auth if auth else self.config)
    
    def status(self) -> Dict[str, Any]:
        res = self.session.get(get_url("/status", self.config), timeout=HTTP_TIMEOUT).json()
        try:
            if res["whoami"] != "exploitfarm":
                raise Exception()
        except Exception:
            raise ReqsError("Invalid server")
        return res
    
    def submitters(self) -> Any:
        return self.session.get(get_url("/submitters", self.config), timeout=HTTP_TIMEOUT).json()

    def teams(self) -> Any:
        return self.session.get(get_url("/teams", self.config), timeout=HTTP_TIMEOUT).json()
    
    def clients(self) -> Any:
        return self.session.get(get_url("/clients", self.config), timeout=HTTP_TIMEOUT).json()
    
    def flags(self) -> Any:
        return self.session.get(get_url("/flags", self.config), timeout=HTTP_TIMEOUT).json()

    def exploits(self) -> Any:
        return self.session.get(get_url("/exploits", self.config), timeout=HTTP_TIMEOUT).json()
    
    def services(self) -> Any:
        return self.session.get(get_url("/services", self.config), timeout=HTTP_TIMEOUT).json()
    
    def new_submitter(self, data: dict) -> Any:
        return requests_check(self.session.post(get_url("/submitters", self.config), json=jsonify(data), timeout=HTTP_TIMEOUT).json())
    
    def delete_submitter(self, submitter_id:int) -> Any:
        return requests_check(self.session.delete(get_url(f"/submitters/{submitter_id}", self.config), timeout=HTTP_TIMEOUT).json())
    
    def test_submitter(self, submitter_id:int, flags:list[str]) -> Any:
        return requests_check(self.session.post(get_url(f"/submitters/{submitter_id}/test", self.config), json=flags, timeout=HTTP_TIMEOUT).json())
    
    def setup(self, data: dict) -> Any:
        return requests_check(self.session.post(get_url("/setup", self.config), json=jsonify(data), timeout=HTTP_TIMEOUT).json())
    
    def login(self,password:str) -> str:
        try:
            return self.session.post(get_url("/login", self.config), data={"grant_type":"password", "username": "user", "password": password}, timeout=HTTP_TIMEOUT).json()["access_token"]
        except KeyError:
            raise ReqsError("Failed to login")
    
    def authenicate(self, password:str, save:bool = True) -> str|None:
        auth_key = self.login(password)
        self.refresh_session(auth_key)
        status = self.status()
        auth_key = status.get("auth_key", None)
        self.refresh_session(auth_key)
        self.config.server.auth_key = auth_key
        if save: self.config.write()
        return auth_key
    
    def new_client(self, data: dict) -> Any:
        return requests_check(self.session.post(get_url("/clients", self.config), json=jsonify(data), timeout=HTTP_TIMEOUT).json())
    
    def self_subscribe_client(self) -> Any:
        return self.new_client({"name": self.config.client_name, "id": self.config.client_id})
            
    def new_teams(self, data: list) -> Any:
        return requests_check(self.session.post(get_url("/teams", self.config), json=jsonify(data), timeout=HTTP_TIMEOUT).json())
    
    def new_service(self, data: dict) -> Any:
        return requests_check(self.session.post(get_url("/services", self.config), json=jsonify(data), timeout=HTTP_TIMEOUT).json())
    
    def new_exploit(self, data: dict) -> Any:
        return requests_check(self.session.post(get_url("/exploits", self.config), json=jsonify(data), timeout=HTTP_TIMEOUT).json())
    
    def submit_flags(self, data: list[dict], exploit:UUID|None = None) -> Any:
        if not exploit:
            return requests_check(self.session.post(get_url("/exploits/submit", self.config), json=jsonify(data), timeout=HTTP_TIMEOUT).json())
        else:
            return requests_check(self.session.post(get_url(f"/exploits/{exploit}/submit", self.config), json=jsonify(data), timeout=HTTP_TIMEOUT).json())

