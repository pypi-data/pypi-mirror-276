def number1():
    """ФОМУЛЫ ПОЛНОЙ ВЕРОЯТНОСТИ И БАЙЕСА

1 ПРОТОТИП УСЛОВИЕ:
В первой корзине имеется 11 шаров, при этом количество белых шаров равно либо 3, либо 10. Оба варианта равновероятны. Во второй корзине имеется 25 шаров, а количество белых шаров равно 2, 23 или 25. Эти три варианта также равновероятны. Из обеих корзин все шары перекладываются в третью корзину. 1) Какова вероятность P(A)
, что случайно вынутый из третьей корзины шар окажется белым (событие A
)? 2) Найдите условную вероятность P(H|A)
, того, что случайно вынутый из третьей корзины шар первоначально находился в первой корзине (событие H
), при условии, что он белый (событие A
)?

1 ПРОТОТИП РЕШЕНИЕ:
p_H1 = 11/36
p_H2 = 25/36
p_h1 = 1/2
p_h2 = 1/2
p_A_H1_h1 = 3/11
p_A_H1_h2 = 10/11
p_A_H1 = p_h1*p_A_H1_h1 + p_h2*p_A_H1_h2
p_h1 = p_h2 = p_h3 = 1/3
p_A_H2_h1 = 2/25
p_A_H2_h2 = 23/25
p_A_H2_h3 = 1
p_A_H2 = p_h1*p_A_H2_h1 + p_h2*p_A_H2_h2 + p_h3*p_A_H2_h3
p_A = p_H1*p_A_H1 + p_H2*p_A_H2
p_H1_A = p_H1*p_A_H1/p_A
p_A, p_H1_A


2 ПРОТОТИП УСЛОВИЕ:
Имеется две корзины с белыми и черными шарами. В первой корзине всего 6 шаров, при этом количество белых шаров распределено по биномиальному закону с параметрами n = 3 и p = 0,8. Во второй корзине имеется всего 11 шаров, при этом количество белых шаров распределено по биномиальному закону с параметрами n = 4 и p = 0,7. Из обеих корзин все шары перекладываются в третью корзину. 1) Какова вероятность P(A)
, что случайно вынутый из третьей корзины шар окажется белым (событие A
)? 2) Найдите условную вероятность P(H|A)
, того, что случайно вынутый из третьей корзины шар первоначально находился в первой корзине (событие H
), при условии, что он белый (событие A
)?

2 ПРОТОТИП РЕШЕНИЕ:
p_H1 = 6/17
p_H2 = 9/17
n1 = 3
p1 = 0.8
X1 = binom(n1, p1)
E_X1 = X1.mean()
n2 = 4
p2 = 0.7
X2 = binom(n2, p2)
E_X2 = X2.mean()
p_A = (E_X1+E_X2)/17
p_H1_A = p_H1*(E_X1/6)/p_A
p_A, p_H1_A


3 ПРОТОТИП УСЛОВИЕ:
Имеется две корзины с белыми и черными шарами. В первой корзине количество белых – 9, количество черных – 13. Во второй корзине количество белых – 19, количество черных – 20. Из первой корзины случайно, без возвращения, излекаются 7 шаров, а из второй – 8 шаров. Отобранные из обеих корзин шары перекладываются в третью корзину. 1) Какова вероятность P(A)
, что случайно вынутый из третьей корзины шар окажется белым (событие A
)? 2) Найдите условную вероятность P(H|A)
, того, что случайно вынутый из третьей корзины шар первоначально находился в первой корзине (событие H
), при условии, что он белый (событие A
)?

3 ПРОТОТИП РЕШЕНИЕ:
wt1, bl1 = 9, 13
wt2, bl2 = 19, 20
take1 = 7
take2 = 8
balls1 = wt1 + bl1
balls2 = wt2 + bl2
p_h1 = take1 / (take2 + take1)
p_h2 = take2 / (take2 + take1)
p_ah1 = wt1 / balls1
p_ah2 = wt2 / balls2
p_a = p_h1 * p_ah1 + p_h2 * p_ah2
print(f"{p_a}".replace(".", ","))
p_ha = p_h1 * p_ah1 / p_a
print(f"{p_ha}".replace(".", ","))"""


def number2():
    """СПЕЦИАЛЬНЫЕ ДИСКРЕТНЫЕ СЛУЧАЙНЫЕ СОБЫТИЯ

1 ПРОТОТИП УСЛОВИЕ:
Банк выдал кредиты двум группам заемщиков: 180 заемщиков в первой группе и 70 – во второй. Известно, что заемщики из первой группы возвращают кредит с вероятностью 0,93, а заемщики из второй группы – с вероятностью 0,92. Пусть X
 – суммарное количество возвращенных кредитов для обеих групп. Предполагая независимость заемщиков, найдите: 1) стандартное отклонение X
; 2) асимметрию X
. Указание: используйте присущее третьему центральному моменту свойство аддитивности (основное свойство семиинвариантов).

1 ПРОТОТИП РЕШЕНИЕ:
n1, p1 = 180, 0.93
n2, p2 = 70, 0.92
var_S1 = n1 * p1 * (1 - p1)
var_S2 = n2 * p2 * (1 - p2)
var_S = var_S1 + var_S2
std_S = np.sqrt(var_S)
skew_S1 = (1 - 2 * p1) / np.sqrt(n1 * p1 * (1 - p1))
skew_S2 = (1 - 2 * p2) / np.sqrt(n2 * p2 * (1 - p2))
combined_skewness = (skew_S1 * var_S1**1.5 + skew_S2 * var_S2**1.5) / var_S**1.5
std_S, combined_skewness


2 ПРОТОТИП УСЛОВИЕ:
Независимые пуассоновские случайные величины X,Y,Z
 имеют следующие стандартные отклонения: σX=0,3
; σY=0,9
; σZ=1,8
. Пусть S=X+Y+Z
. Найдите: 1) вероятность P(S=7)
; 2) наиболее вероятное значение суммы S
; 3) стандартное отклонение σS
; 4) асимметрию As(S)
; 5) эксцесс Ex(S)

2 ПРОТОТИП РЕШЕНИЕ:
sig1 = 0.3
sig2 = 0.9
sig3 = 1.8
x = 7
var1 = sig1 ** 2
var2 = sig2 ** 2
var3 = sig3 ** 2
l = var1 + var2 + var3
p = (l ** x / math.factorial(x)) * math.e ** (-l)
s_n = round(l)
sigmax = l ** 0.5
AS = 1 / sigmax
Ex = 1 / l
print(f"{p}".replace(".", ","))
print(f"{s_n}".replace(".", ","))
print(f"{sigmax}".replace(".", ","))
print(f"{AS}".replace(".", ","))
print(f"{Ex}".replace(".", ","))


3 ПРОТОТИП УСЛОВИЕ:
Монеты в количестве 11
 штук подбрасываются до тех пор, пока 14 раз не выпадет 5
 гербов. Пусть X
 – число бросков до первого появления 5
 гербов, а Y
 – число бросков до последнего появления 5
 гербов (Y
 = общее число бросков). Найдите: 1) математическое ожидание X
2) стандартное отклонение X
3) коэффициент корреляции между X
 и Y
4) математическое ожидание XY

3 ПРОТОТИП РЕШЕНИЕ:
import math
n = 11
count_g = 14
gerb = 5
P = math.comb(n, gerb) / 2**n
E_X = 1/P
print(E_X)
var_x = (1-P)/P**2
std_x = var_x**0.5
print(std_x)
po = var_x / (std_x * std_x * count_g**0.5)
print(po)
E_XY = var_x + count_g*E_X**2
print(E_XY)


4 ПРОТОТИП УСЛОВИЕ:
Корзина содержит 34
 шаров, среди которых 14
 – красных и 5
 – синих. Из корзины, случайным образом, без возвращения извлекаются 12
 шаров. Пусть X
 и Y
 обозначают количество красных и синих шаров среди извлеченных, соответственно. Найдите ковариацию Cov(X,Y)

4 ПРОТОТИП РЕШЕНИЕ:
-------"""


def number3():
    """УСЛОВНЫЕ ХАРАКТЕРИСТИКИ ОТНОСИТЕЛЬНО ГРУППЫ СОБЫТИЙ

1 ПРОТОТИП УСЛОВИЕ:
Несимметричная игральная кость подбрасывается до тех пор, пока не выпадут цифры 4
 и 5
. Пусть X
 — число сделанных при этом бросков. Даны вероятности появления цифр в одном броске: P(4)=0,11
 и P(5)=0,22
. Требуется найти: 1) E(X)
; 2) дисперсию X
, если известно, что из 4
 и 5
 сначала выпала цифра 5

1 ПРОТОТИП РЕШЕНИЕ:
a = 0.11
b = 0.22
e = 1 / a + 1 / b - (1 / (a + b))
print(f"{e}".replace(".", ","))
x1=geom(a)
x2=geom(b)
print(x1.var()  +x2.var())


2 ПРОТОТИП УСЛОВИЕ:
Несимметричная игральная кость подбрасывается до тех пор, пока не выпадут цифры 1
, 2
 и 4
. Пусть X
 — число сделанных при этом бросков. Даны вероятности появления цифр в одном броске: P(1)=0,14
, P(2)=0,19
 и P(4)=0,13
. Требуется найти: 1) E(X)
; 2) дисперсию X
, если известно, что из 1
, 2
 и 4
 сначала выпала цифра 1
, затем — 2

2 ПРОТОТИП РЕШЕНИЕ:
a = 0.14
b = 0.19
c = 0.13
e = 1 / a + 1 / b + 1 / c - (1 / (a + b) + 1 / (a + c) + 1 / (b + c)) + 1 / (a + b + c)
print(e)
x1=geom(a + b + c)
x2=geom(b + c)
x3=geom(c)
print(x1.var() + x2.var() + x3.var())"""


def number4():
    """ПРИБЛИЖЕННОЕ ВЫЧИСЛЕНИЕ ВЕРОЯТНОСТИ МЕТОДОМ МОНТЕ-КАРЛО

1 ПРОТОТИП УСЛОВИЕ:
В прямоугольной области, заданной ограничениями |x|⩽20
 и |y|⩽8
, случайным образом выбираются две точки: (x1,y1)
 и (x2,y2)
. Пусть A
 и B
 – события, состоящие в том, что: A
 – расстояние между выбранными точками меньше 11; B
 – модуль разности |x1−x2|
 меньше 14. Найдите приближенно, методом Монте-Карло: 1) вероятность P(A)
; 2) условную вероятность P(A|B)
Указание: получите в заданной прямоугольной области 100000 пар точек и, используя все эти точки, найдите ответы, округляя их до одного знака после запятой.

1 ПРОТОТИП РЕШЕНИЕ:
num_trials = 100000
x_limit = 20
y_limit = 8
distance_threshold = 11
x_diff_threshold = 14
x1 = np.random.uniform(-x_limit, x_limit, num_trials)
y1 = np.random.uniform(-y_limit, y_limit, num_trials)
x2 = np.random.uniform(-x_limit, x_limit, num_trials)
y2 = np.random.uniform(-y_limit, y_limit, num_trials)
distances = np.sqrt((x1 - x2)**2 + (y1 - y2)**2)
x_diffs = np.abs(x1 - x2)
event_A = distances < distance_threshold
event_B = x_diffs < x_diff_threshold
P_A = np.mean(event_A)
P_A_given_B = np.mean(event_A[event_B])
round(P_A, 1), round(P_A_given_B, 1)


2 ПРОТОТИП УСЛОЛВИЕ:
В области, ограниченной эллипсом (u/13)**2+(v/6)**2=1
, случайным образом выбираются две точки. Пусть A
 и B
 – события, состоящие в том, что: A
 – расстояние между выбранными точками меньше 7,9; B
 – все координаты обеих точек больше 0. Найдите приближенно, методом Монте-Карло: 1) вероятность P(A)
; 2) условную вероятность P(A|B)
. Указание: получите внутри заданного эллипса 100000 пар точек и, используя все эти пары точек, найдите ответы, округляя их до одного знака после запятой.

2 ПРОТОТИП РЕШЕНИЕ:
N = 2000
denomin_u = 13
denomin_v = 6
distance_u_v = 7.9
coordinate_u_v = 0
u = np.random.uniform(-denomin_u, denomin_u, N)
v = np.random.uniform(-denomin_v, denomin_v, N)
inside_ellipse = (u**2 / denomin_u**2 + v**2 / denomin_v**2) <= 1
u_filtered = u[inside_ellipse]
v_filtered = v[inside_ellipse]
count_A = 0
count_B = 0
count_A_and_B = 0
for i in range(len(u_filtered)):
    for j in range(i+1, len(u_filtered)):
        distance = np.sqrt((u_filtered[i] - u_filtered[j])**2 + (v_filtered[i] - v_filtered[j])**2)
        if distance < distance_u_v:
            count_A += 1
            if u_filtered[i] > coordinate_u_v and v_filtered[i] > coordinate_u_v and u_filtered[j] > coordinate_u_v and v_filtered[j] > coordinate_u_v:
                count_A_and_B += 1
        if u_filtered[i] > coordinate_u_v and v_filtered[i] > coordinate_u_v and u_filtered[j] > coordinate_u_v and v_filtered[j] > coordinate_u_v:
            count_B += 1
p_A = count_A / (len(u_filtered) * (len(u_filtered) - 1) / 2)
p_A_given_B = count_A_and_B / count_B
print(f"Вероятность P(A): {p_A}")
print(f"Условная вероятность P(A|B): {p_A_given_B}")


3 ПРОТОТИП УСЛОВИЕ:
В области, ограниченной эллипсом (u/23)**2+(v/6)**2=1
, случайным образом выбираются две точки. Пусть A
 и B
 – события, состоящие в том, что: A
 – расстояние между выбранными точками меньше 9,2; B
 – координаты первой точки больше 0, а координаты второй точки меньше 0. Найдите приближенно, методом Монте-Карло: 1) вероятность P(A)
; 2) условную вероятность P(A|B)
. Указание: получите внутри заданного эллипса 100000 пар точек и, используя все эти пары точек, найдите ответы, округляя их до одного знака после запятой.

3 ПРОТОТИП РЕШЕНИЕ:
------


4 ПРОТОТИП УСЛОВИЕ:
В кубе объема 1 случайным образом выбираются точки A
, B
 и C
. Пусть R
, S
 и T
 – события, состоящие в том, что: R
 – наименьший угол в треугольнике ABC
 меньше 26,7°; S
 – наибольший угол в треугольнике ABC
 меньше 81,9°; T
 – треугольник ABC
 остроугольный. Найдите приближенно, методом Монте-Карло: 1) условную вероятность P(R|T)
; 2) условную вероятность P(S|T)
. Указание: получите 100000 остроугольных треугольников ABC
 и, используя все эти треугольники, найдите ответы, округляя их до одного знака после запятой.

4 ПРОТОТИП РЕШЕНИЕ:
N = 100000
R = 0
S = 0
T = 0
for i in range(0, N + 1):
    x1 = rand.uniform(0, 1)
    y1 = rand.uniform(0, 1)
    z1 = rand.uniform(0, 1)
    x2 = rand.uniform(0, 1)
    y2 = rand.uniform(0, 1)
    z2 = rand.uniform(0, 1)
    x3 = rand.uniform(0, 1)
    y3 = rand.uniform(0, 1)
    z3 = rand.uniform(0, 1)
    a = ((x2 - x1)**2 + (y2 - y1)**2 + (z2 - z1)**2)**0.5
    b = ((x3 - x2)**2 + (y3 - y2)**2 + (z3 - z2)**2)**0.5
    c = ((x1 - x3)**2 + (y1 - y3)**2 + (z1 - z3)**2)**0.5
    cos_A = (b**2 + c**2 - a**2) / (2 * b * c)
    A = math.acos(cos_A) * 180 / math.pi
    cos_B = (a**2 + c**2 - b**2) / (2 * a * c)
    B = math.acos(cos_B) * 180 / math.pi
    cos_C = (a**2 + b**2 - c**2) / (2 * a * b)
    C = math.acos(cos_C) * 180 / math.pi
    if max(A, B, C) < 90:
        T += 1
        if max(A, B, C) < 81.9:
            S += 1
        if min(A, B, C) < 26.7:
            R += 1
R_T = R / T
S_T = S / T
print(round(R_T,1))
print(round(S_T,1))"""


def number5():
    """НЕПРЕРЫВНЫЕ СЛУЧАЙНЫЕ ВЕЛИЧИНЫ

1 ПРОТОТИП УСЛОВИЕ:
бсолютно непрерывная случайная величина X
 может принимать значения только в отрезке [4,7]
. На этом отрезке плотность распределения случайной величины X
 имеет вид: f(x)=C(1+3x0,5+6x0,7+9x0,9)1,5
, где C
 – положительная константа. Найдите: 1) константу C
; 2) математическое ожидание E(X)
; 3) стандартное отклонение σX
; 4) квантиль уровня 0,8
 распределения X

1 ПРОТОТИП РЕШЕНИЕ:
def f(x, C):
    return C * ((1 + 3*x**0.5 + 6*x**0.7 + 9*x**0.9)**1.5)
def integral_C(C):
    result, _ = quad(f, 4, 7, args=(C))
    return result - 1
res = opt.fsolve(integral_C, 0.1)
C = res[0]
class rv_continuous_f(rv_continuous):
    def _pdf(self, x):
        pdf_values = np.zeros_like(x)
        pdf_values = np.where((4 <= x) & (x <= 7), f(x, C), pdf_values)
        return pdf_values
X = rv_continuous_f(a=4, b=7)
print(C)
print(X.mean())
print(X.std())
print(X.ppf(0.8))


2 ПРОТОТИП УСЛОВИЕ:
Случайная величина X
 равномерно распределена на отрезке [4,8]
. Случайная величина Y
 выражается через X
 следующим образом: Y=(1+6X0,5+4X0,7+5X0,9)1,3
. Найдите: 1) математическое ожидание E(Y)
; 2) стандартное отклонение σY
; 3) асимметрию As(Y)
; 4) квантиль уровня 0,8
 распределения Y

2 ПРОТОТИП РЕШЕНИЕ:
a = 4
b = 8
def Y(x):
    return (1 + 6*(x**0.5) + 4*(x**0.7) + 5*(x**0.9))**1.3
X = uniform(a, b-a)
def E_Y():
    integrand = lambda x: Y(x) * X.pdf(x)
    EY_value, _ = quad(integrand, a, b)
    return EY_value
def std_Y():
    integrand = lambda x: ((Y(x)-E_Y())**2)*X.pdf(x)
    Var_Y, _ = quad(integrand, a, b)
    return math.sqrt(Var_Y)
def skew_Y():
    integrand = lambda x: (((Y(x) - E_Y()) / std_Y())**3) * X.pdf(x)
    skew, _ = quad(integrand, a, b)
    return skew
print(np.around(E_Y(), 1))
print(np.around(std_Y(), 2))
print(np.around(skew_Y(), 4))
q = 0.8
q_Y = Y(X.ppf(q))
print(np.around(q_Y, 3))"""


def number6():
    """НОРМАЛЬНЫЕ СЛУЧАЙНЫЕ ВЕКТОРЫ

1 ПРОТОТИП УСЛОВИЕ:
Для нормального случайного вектора (X,Y)∼N(−8;16;49;1;0,8) найдите вероятность P((X−3)(Y−7)<0)

1 ПРОТОТИП РЕШЕНИЕ:
u_X = -8
mu_Y = 16
sigma_X = 49 ** 0.5
sigma_Y = 1 ** 0.5
ro = 0.8
cov_XY = ro*sigma_X*sigma_Y
mu_list = [mu_X,mu_Y]
cov_matrix = [[sigma_X**2,cov_XY],[cov_XY,sigma_Y**2]]
XY = multivariate_normal(mean=mu_list,cov=cov_matrix)
P = XY.cdf([np.inf,7])-XY.cdf([3,7])+(XY.cdf([3,np.inf])-XY.cdf([3,7]))
P


2 ПРОТОТИП УСЛОВИЕ:
Для нормального случайного вектора (X,Y)∼N(−4;4;64;81;−0,31)
найдите вероятность P((X−8)(X−10)(Y−1)<0)

2 ПРОТОТИП РЕШЕНИЕ:
mu_X = -4
mu_Y = 4
sigma_X = 64 ** 0.5
sigma_Y = 81 ** 0.5
ro = -0.31
cov_XY = ro*sigma_X*sigma_Y
mu_list = [mu_X, mu_Y]
cov_matrix = [[sigma_X**2, cov_XY], [cov_XY, sigma_Y**2]]
XY = multivariate_normal(mean=mu_list, cov=cov_matrix)
X=norm(mu_X, sigma_X)
Y=norm(mu_Y,sigma_Y)
Pa=XY.cdf([8,1])
Pb=X.cdf(10)-X.cdf(8)-(XY.cdf([10,1])-XY.cdf([8,1]))
Pc=Y.cdf(1)-XY.cdf([10,1])
PA=Pa+Pb+Pc
PA"""
